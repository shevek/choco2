%\part{solver}
\label{solver}
\hypertarget{solver}{}


\chapter{The solver}\label{solver:thesolver}\hypertarget{solver:thesolver}{}

%\section{How to create a solver}\label{solver:howtocreateasolver}\hypertarget{solver:howtocreateasolver}{}

To create a {\tt Solver}, one just needs to create a new object as follow:
\begin{lstlisting}
Solver solver = new CPSolver();
\end{lstlisting}
By this, a Constraint Programming (CP) {\tt Solver} object is created. 

%\section{Read a model}\label{solver:readamodel}\hypertarget{solver:readamodel}{}
The solver gives an API to read a model. The reading of a model is compulsory and must be done after the entire definition of the model. 
\begin{lstlisting}
solver.read(model);
\end{lstlisting}
The reading is divided in 2 parts: \hyperlink{solver:variablesreading}{variables reading} and \hyperlink{solver:constraintsreading}{constraints reading}.

\section{Variables reading}\label{solver:variablesreading}\hypertarget{solver:variablesreading}{}
The solver iterates over the variables of the Model to create solver-specific variables and domains (as defined in the model). 
Thus, three types of variables can be created: integer variables, real variables and set variables. 
Depending on the constructor, the correct domain is created (like bounded domain or enumerated domain for integer variables). 

\begin{note}
\textbf{Bound variables} are related to large domains which are only represented by their lower and upper bounds. The domain is encoded in a space efficient way and propagation events only concern bound updates. Value removals between the bounds are therefore ignored (\emph{holes} are not considered). The level of consistency achieved by most constraints on these variables is called \emph{bound-consistency}.

On the contrary, the domain of an \textbf{enumerated variable} is explicitly represented and every value is considered while pruning. Basic constraints are therefore often able to achieve \emph{arc-consistency} on enumerated variables (except for NP global constraint such as the cumulative constraint). Remember that switching from an enumerated variable to a bounded variables decrease the level of propagation achieved by the system.
\end{note}

%\begin{note}
Model variables and Solver variables are distinct. Solver variables are solver representation of the model variables. One can't access to variable value directly from the model variable. To access to a model variable thanks to the solver, use the following \texttt{Solver} API: \mylst{getVar(Variable v);}
%\end{note}

\subsection{Solver and IntegerVariables}\label{solver:solverandintegervariables}\hypertarget{solver:solverandintegervariables}{}

A model integer variable can be accessed by the method \textbf{\tt getVar(IntegerVariable v)} which returns a \textbf{\tt IntDomainVar} object:
\begin{lstlisting}
  IntegerVariable x = makeEnumIntVar("x", 1, 100);  // model variable
  IntDomainVar xOnSolver = solver.getVar(x);  // solver variable
\end{lstlisting}

The state of an \texttt{IntDomainVar} can be accessed through the main following public methods :

\noindent\begin{tabular}{p{.3\linewidth}p{.7\linewidth}}
  \hline
  \texttt{IntDomainVar} API &  description \\
  \hline
	\mylst{hasEnumeratedDomain()} &checks if the variable is an enumerated or a bound one\\
	\mylst{getInf()} &returns the lower bound of the variable\\
	\mylst{getSup()} &returns the upper bound of the variable\\
	\mylst{getVal()} &returns the value if it is instantiated\\
	\mylst{isInstantiated()} &checks if the domain is reduced to a singleton\\
	\mylst{canBeInstantiatedTo(int v)} &checks if the value \emph{v} is contained in the domain of the variable\\
	\mylst{getDomainSize()} &returns the current size of the domain\\
  \hline\\
\end{tabular}

For more informations on advanced uses of such \texttt{IntDomainVar}, see \hyperlink{advanced}{advanced uses}.

\subsection{Solver and SetVariables}\label{solver:solverandsetvariables}\hypertarget{solver:solverandsetvariables}{}

A model set variable can be access by the method \textbf{\tt getVar(SetVariable v)} which returns a \textbf{\tt SetVar} object:
\begin{lstlisting}
	SetVariable x = makeBoundSetVar("x", 1, 40); // model variable
	SetVar xOnSolver = solver.getVar(x); // solver variable
\end{lstlisting}
A set variable on integer values between $[1,n]$ has $2^{n}$ values (every possible subsets of $\{1..n\}$). This makes an exponential number of values and the domain is represented with two bounds corresponding to the intersection of all possible sets (called the kernel) and the union of all possible sets (called the envelope) which are the possible candidate values for the variable.

The state of a \texttt{SetVar} can be accessed through the main following public methods on the SetVar class:

\noindent\begin{tabular}{p{.3\linewidth}p{.7\linewidth}}
  \hline
  \texttt{SetVar} API &  description \\
  \hline
	\mylst{getCard()} &returns the \texttt{IntDomainVar} representing the cardinality of the set variable\\
	\mylst{isInDomainKernel(int v)} &checks if value \emph{v} is contained in the current kernel\\
	\mylst{isInDomainEnveloppe(int v)} &checks if value \emph{v} is contained in the current envelope\\
	\mylst{getDomain()} &returns the domain of the variable as a \texttt{SetDomain}. Iterators on envelope or kernel can than be called\\
	\mylst{getKernelDomainSize()} &returns the size of the kernel\\
	\mylst{getEnveloppeDomainSize()} &returns the size of the envelope\\
	\mylst{getEnveloppeInf()} &returns the first available value of the envelope\\
	\mylst{getEnveloppeSup()} &returns the last available value of the envelope\\
	\mylst{getKernelInf()} &returns the first available value of the kernel\\
	\mylst{getKernelSup()} &returns the last available value of the kernel\\
	\mylst{getValue()} &returns a table of integers \texttt{int[]} containing the current domain\\
  \hline\\
\end{tabular}


For more informations on advanced uses of such \texttt{SetVar}, see \hyperlink{advanced}{advanced uses}.

\subsection{Solver and RealVariables}\label{solver:solverandrealvariables}\hypertarget{solver:solverandrealvariables}{}

\begin{note}
\emph{Real variables are still under development but can be used to solve toy problems such as small systems of equations.}
\end{note}
 
A model real variable can be access by the method \textbf{\tt getVar(RealVariable v)} which returns a \texttt{RealVar} object:
\begin{lstlisting}
	RealVariable x = makeRealVar("x", 1.0, 3.0); // model variable
	RealVar xOnSolver = s.getVar(x); // solver variable
\end{lstlisting}

Continuous variables are useful for non linear equation systems which are encountered in physics for example.

\noindent\begin{tabular}{p{.3\linewidth}p{.7\linewidth}}
  \hline
  \texttt{RealVar} API &  description \\
  \hline
	\mylst{getInf()} &returns the lower bound of the variable (\texttt{double})\\
	\mylst{getSup()} &returns the upper bound of the variable (\texttt{double})\\
	\mylst{isInstantiated()} &checks if the domain of a variable is reduced to a canonical interval. A canonical interval indicates that the domain has reached the precision given by the user or the solver\\
  \hline\\
\end{tabular}


For more informations on advanced uses of such \texttt{RealVar}, see \hyperlink{advanced}{advanced uses}.

\section{Constraints reading}\label{solver:constraintsreading}\hypertarget{solver:constraintsreading}{}
After variables, the Solver iterates over the constraints added to the Model. It creates Solver constraints that encapsulates a filtering algorithm which are called when a propagation step occur or when external events happen on the variables belonging to the constraint, such as value removals or bounds modifications. And it add it to the constraint network. 

\section{Search Strategy}\label{solver:searchstrategy}\hypertarget{solver:searchstrategy}{}

A key ingredient of any constraint approach is a clever branching strategy. The construction of the search tree is done according to a series of Branching objects (that plays the role of achieving intermediate goals in logic programming). The user may specify the sequence of branching objects to be used to build the search tree. A common way to branch in CP is by assigning variables to values (such a branching is called \textbf{\tt AssignVar} in choco). We will present in this section how to define your branching strategies with existing variables and values selectors. 

\subsection{Why is it important to define a search strategy ?}\label{solver:whyisitimportanttodefineasearchstrategy}\hypertarget{solver:whyisitimportanttodefineasearchstrategy}{}

Once a fix point is reached, the Solver needs to select a variable and its value to continue the search. The way variables and values are chosen has a \textbf{real impact on the resolution step efficient}. 
\begin{note}
\emph{The search strategy should not be overlooked!!}
An adapted search strategy can reduce: the execution time, the number of node expanded, the number of backtrack done.
\end{note}
Let see that small example:
\begin{lstlisting}
	Model m = new CPModel();
	int n = 1000;
	IntegerVariable var = makeBoundIntVar("var", 0, 2);
	IntegerVariable[] bi = makeEnumIntVarArray("b", n, 0, 1);
	m.addConstraint(eq(var, sum(bi)));
	
	Solver badStrat = new CPSolver();
	badStrat.read(m);
	badStrat.setVarIntSelector(new MinDomain(badStrat));
	badStrat.setValIntIterator(new IncreasingDomain());
	badStrat.solve();
	badStrat.printRuntimeSatistics();
	
	Solver goodStrat = new CPSolver();
	goodStrat.read(m);
	goodStrat.setVarIntSelector(new MinDomain(goodStrat, 
                                              goodStrat.getVar(new IntegerVariable[]{var})));
	goodStrat.setValIntIterator(new DecreasingDomain());
	goodStrat.solve();
	goodStrat.printRuntimeSatistics();
\end{lstlisting}

This model ensures that $var = b_{0} + b_{1} + \ldots + b_{1000}$ where \emph{var} has a small domain and $b_{i}$ is a binary variable. The propagation has no effect on any domain and a fix point is reached at the beginning of the search. So, a decision has to be done choosing a variable and its value. As the default variable selector is \texttt{MinDomain} (see below), the solver will iterate over the variables, starting by the 1000 binary variables and ending with \emph{var}, and 1001 nodes will be created.

\subsection{Variable and value selection}\label{solver:variableandvalueselection}\hypertarget{solver:variableandvalueselection}{}

A common way to explore the search tree in CP is by assigning values to variables. The branching class of Choco dedicated to this kind of search is \texttt{\bf AssignVar}. More complex branching schemes can be performed in Choco but this section lists the default strategies available for exploring the search tree by assigning variables and that can be used within an \texttt{AssignVar} branching. These strategies are called \emph{variable and value selection heuristics}. 

The heuristics available in Choco and the API for selecting a given heuristic depend on the type of the considered variables. 
As instance, for integer variables, the default branching heuristic used by Choco is to choose the variable with current minimum domain size first (\texttt{MinDomain}) and to take its values in increasing order (\texttt{IncreasingDomain}). 
Customizing the value and variable heuristics on the integer variables of the solver can be done (before calling the \texttt{solve()} method) using the \texttt{Solver} API, as shown in the following example:
\begin{lstlisting}
  // select the next branching variable randomly
  solver.setVarIntSelector(new RandomIntVarSelector(solver));
  // select the values in increasing order
  solver.setValIntIterator(new DecreasingDomain());
  // *OR* select the next value randomly
  solver.setValIntSelector(new RandomIntValSelector());
\end{lstlisting}

\subsubsection{Variable selector.}\label{solver:variableselector}\hypertarget{solver:variableselector}{}
It defines the way to choose the non instantiated variable on which the next decision will be made.
A variable selector can be set using the following API:

\noindent\begin{tabular}{p{.4\linewidth}p{.2\linewidth}p{.3\linewidth}}
  \hline
  \texttt{Solver} API &  Variable &  Default strategy \\
  \hline
  \mylst{setVarIntSelector(VarSelector)} &  Integer  &  MinDomain \\
  \mylst{setVarRealSelector(RealVarSelector)} &  Real &  CyclicRealVarSelector \\
  \mylst{setVarSetSelector(SetVarSelector)} &  Set  &  MinDomSet \\
  \hline\\
\end{tabular}

\noindent The variable selectors currently available in Choco are the following: \todo{to complete}

\noindent\begin{tabular}{p{.5\linewidth}p{.5\linewidth}}
  \hline
  Integer Variable Selector &  description \\
  \hline
  \mylst{StaticVarOrder(IntDomainVar[])} & A heuristic selecting the first non instantiated variable in the given static order \\
  \mylst{MinDomain(Solver, IntDomainVar[])} & A heuristic selecting the variable with smallest domain \\
  \mylst{DomOverDeg(Solver, IntDomainVar[])} & A heuristic selecting the variable with smallest ration (domainSize / degree), the \emph{degree} of a variable is the number of constraints linked to it. \\
  \mylst{DomOverDynDeg(Solver, IntDomainVar[])} & A heuristic selecting the variable with smallest degree, the \emph{degree} of a variable is the number of constraints linked to it that is not completely instanciated. \\
  \mylst{DomOverWDeg(Solver, IntDomainVar[])} & see \hyperlink{solver:dom/wdeg}{example}. \\
  \mylst{MostConstrained(final Solver, final IntDomainVar[])} & A heuristic selecting the variable with the maximum degree \\
  \mylst{RandomIntVarSelector(Solver, IntDomainVar[], long)} & A heuristic selecting randomly the non instantiated variable \\
  \mylst{CompositeIntVarSelector(ConstraintSelector, HeuristicIntVarSelector)} & Composes two heuristics for selecting a variable: a first heuristic is applied for selecting a constraint. From that constraint a second heuristic is applied for selecting the variable \\
  \mylst{LexIntVarSelector(HeuristicIntVarSelector, HeuristicIntVarSelector)} & applies two heuristics lexicographically for selecting a variable: a first heuristic is applied finding the best constraint, ties are broken with the second heuristic \\
  &\\
  \hline
  Set Variable Selector & description   \\
  \hline
  \mylst{MinDomSet(Solver)} &A heuristic selecting the variable with the smallest domain \\
  \mylst{RandomSetVarSelector(Solver, SetVar[], long)} &A heuristic selecting randomly the variable \\
  \mylst{StaticSetVarOrder(SetVar[])} &A heuristic selecting the first non instantiated variable in the given static order \\
  &\\
  \hline
  Real Variable Selector &  description \\
  \hline
  \mylst{CyclicRealVarSelector(Solver solver)} &Since a dichotomy algorithm is used, cyclic assiging is nedded for instantiate a real interval variable. A variable is selected several times to split its domain until it reaches the desired precision \\
  \hline\\
\end{tabular}

\begin{note}
Solver variables have to be specified (not Model variables).
\end{note}

\subsubsection{Value iterator}\label{solver:valueiterator}\hypertarget{solver:valueiterator}{}
Once the variable has been choose, the Solver has to compute its value. The first way to do it is to schedule the value once and give an iterator to the solver. It can be done using the following API: 

\noindent\begin{tabular}{p{.4\linewidth}p{.2\linewidth}p{.3\linewidth}}
  \hline
  Solver API &  Variable &  Default strategy \\
  \hline
  \mylst{setValIntIterator(ValIterator)} &  Integer &  IncreasingDomain \\
  \mylst{setValRealIterator(RealValIterator)} &  Real &  RealIncreasingDomain \\
  \mylst{setValSetIterator(ValIterator)} &  Set &  MinEnv \\
  \hline\\
\end{tabular}

\noindent The value iterators currently available in Choco are the following: \todo{to complete}

\noindent\begin{tabular}{p{.3\linewidth}p{.7\linewidth}}
  \hline
  Integer Value Iterator &  description \\
  \hline
  \mylst{DecreasingDomain()} &  A heuristic selecting value from the upper bound to the lower bound \\
  \mylst{IncreasingDomain()} &  A heuristic selecting value from the lower bound to the upper bound \\
  &\\
  \hline
  Real Value Iterator &  description \\
  \hline
  \mylst{RealIncreasingDomain()} &  A heuristic selecting value from the lower bound to the upper bound \\
  \hline\\
\end{tabular}

\subsubsection{Value selector}\label{solver:valueselector}\hypertarget{solver:valueselector}{}
The second way to do it is to compute the following value at each call. It can be done using the following API: 

\noindent\begin{tabular}{p{.4\linewidth}p{.2\linewidth}p{.3\linewidth}}
  \hline
  Solver API &Variable &  Default strategy \\
  \hline
  \mylst{setValIntSelector(ValSelector)} &Integer &  (none: see \emph{value iterator}) \\
  \mylst{setValRealSelector(ValSelector)} &Real &  (none: see \emph{value iterator}) \\
  \mylst{setValSetSelector(SetValSelector)} &Set &  (none: see \emph{value iterator}) \\
  \hline\\
\end{tabular}

\noindent The value selectors currently available in Choco are the following: \todo{to complete}

\noindent\begin{tabular}{p{.3\linewidth}p{.7\linewidth}}
  \hline
  Integer Value Selector & description \\
  \hline
  \mylst{MaxVal()} &  Selecting the highest value in the domain \\
  \mylst{MidVal()} &  Selecting the middle value in the domain \\
  \mylst{MinVal()} &  Selecting the lowest value in the domain \\
  \mylst{RandomIntValSelector()} &  Selecting randomly the value in the domain \\
  &\\
  \hline
  Set Value Selector & description \\
  \hline
  \mylst{MinEnv(Solver)} &  Selecting the lowest value in the envelope and not in the kernel of the domain \\
  \hline\\
\end{tabular}

% SOFREM: duplicated section see advanced
\subsection{Building a sequence of branching object}\label{solver:buildingasequenceofbranchingobject}\hypertarget{solver:buildingasequenceofbranchingobject}{}

You might want to apply different heuristics to different set of variables of the problem. In that case, the search is viewed as a sequence of branching objects (or goals). Up to now, we only had one branching or one goal including all the variables of the problem but several goals can be used.

Adding a new goal is made through the solver with the \texttt{addGoal(AbstractBranching b)} method. As for the addition of your own limit, dont call the \texttt{solve()} method, but instead: build the solver by yourself, add your sequence of branching, and call the \texttt{launch()} method of the solver. 

The following example add three branching objects on integer variables \emph{vars1}, \emph{vars2} and set variables \emph{svars} to solver \emph{s}. The first two branchings are both \texttt{AssignVar} but use two different variable/values selection strategies:
\begin{lstlisting}
  s.attachGoal(new AssignVar(new MinDomain(s,s.getVar(vars1)), new IncreasingDomain()));
  s.addGoal(new AssignVar(new DomOverDeg(s,s.getVar(vars2)),new DecreasingDomain());
  s.addGoal(new AssignSetVar(new MinDomSet(s,s.getVar(svars)), new MinEnv(s)));
  s.generateSearchStrategy();
  s.launch();
\end{lstlisting}

An example of how to set the search solver in case of optimization in given in the \hyperlink{schedulinganduseofthecumulative:schedulinganduseofthecumulativeconstraint}{tutorial on cumulative}.

\subsection{Dom/WDeg}\label{solver:dom/wdeg}\hypertarget{solver:dom/wdeg}{}
\todo{to introduce}
\begin{lstlisting}
	Solver s = new CPSolver();
	s.read(model);
	    
	s.attachGoal(new DomOverWDegBranching(s, new IncreasingDomain()));
	    
	s.setFirstSolution(true);
	s.generateSearchStrategy();
\end{lstlisting}

The decision variables can be set using :
\begin{lstlisting}
	DomOverWDegBranching dwdeg = new DomOverWDegBranching(s, new IncreasingDomain());
	dwdeg.setBranchingVars(vars);
\end{lstlisting}

\subsection{Impacts}\label{solver:impacts}\hypertarget{solver:impacts}{}
\todo{to introduce}
\begin{lstlisting}
	CPSolver s = new CPSolver();
	s.read(model);
	
	//create the branching on the decision variables vars.
	ImpactBasedBranching ibb = new ImpactBasedBranching(s, vars);
	
	//initialize the impacts with a time limit of 10s 
	ibb.getImpactStrategy().initImpacts(10000);
	
	s.generateSearchStrategy();
	s.attachGoal(ibb);
	s.setFirstSolution(true);
	s.launch();
\end{lstlisting}

\subsection{Restarts}\label{solver:restarts}\hypertarget{solver:restarts}{}

You can set geometric restarts by using the following API available on the solver:
\begin{lstlisting}
setGeometricRestart(int base, double grow);
setGeometricRestart(int base, double grow, int restartLimit);
\end{lstlisting}
It performs a search with restarts regarding the number of backtrack. An initial allowed number of backtrack is given (parameter base) and once this limit is reached a restart is performed and the new limit imposed to the search is increased by multiplying the previous limit with the parameter grow. restartLimit parameter states the maximum number of restarts. Restart strategies makes really sense with strategies that make choices based on the past experience of the search : \texttt{DomOverWdeg} or Impact based search. It could also be used with a random heuristic
\begin{lstlisting}
	CPSolver s = new CPSolver();
	s.read(model);
	
	s.setGeometricRestart(14, 1.5d);
	s.setFirstSolution(true);
	s.generateSearchStrategy();
	s.attachGoal(new DomOverWDegBranching(s, new IncreasingDomain()));
	s.launch();
\end{lstlisting}

You can also set Luby restarts by using the following API available on the solver:
\begin{lstlisting}
setLubyRestart(int base);
setLubyRestart(int base, int grow);
setLubyRestart(int base, int grow, int restartLimit);
\end{lstlisting}
it performs a search with restarts regarding the number of backtracks. One way to describe this strategy is to say that all run lengths are power of two, and that each time a pair of runs of a given length has been completed, a run of twice that length is immediatly executed. The limit is equals to \emph{length*base}.
\begin{itemize}
	\item \textbf{example with growing factor of 2 : [1, 1, 2, 1, 1, 2, 4, 1, 1, 2, 1, 1, 2, 4, 8, 1,...]}
	\item \textbf{example with growing factor of 3 : [1, 1, 1, 3, 1, 1, 1, 3, 9,...]}
\end{itemize}

\begin{lstlisting}
	CPSolver s = new CPSolver();
	s.read(model);
	
	s.setLubyRestart(50, 2, 100);
	s.setFirstSolution(true);
	s.generateSearchStrategy();
	s.attachGoal(new DomOverWDegBranching(s, new IncreasingDomain()));
	s.launch();
\end{lstlisting}

\section{Limiting Search Space}\label{solver:limitingsearchspace}\hypertarget{solver:limitingsearchspace}{}
The Solver class provides some limits on the search strategy that you can fix or just monitor.
Limits may be imposed on the search algorithm to avoid spending too much time in the exploration. The limits are updated and checked each time a new node is created. It has to be specified before the resolution. 
After having created the solver, you can specify whether or not you want to fix a limit:

\begin{description}
\item[time limit] State a time limit on tree search. When the execution time is equal to the time limit, the search stops whatever a solution is found or not. You can define a time limit with the following API : \mylst{setTimeLimit(int timeLimit)} where unit is millisecond. Or just monitor (or not) the search time with the API : \mylst{monitorTimeLimit(boolean b)}. The default value is set to \texttt{true}. Finally, you can get the time limit, once the solve method has been called, with the API: \mylst{getTimeCount()} 
\item[node limit] State a node limit on tree search. When the number of nodes explored is equal to the node limit, the search stops whatever a solution is found or not. You can define a node limit with the following API: \mylst{setNodeLimit(int nodeLimit)} where unit is the number of nodes. Or just monitor (or not) the number of nodes explored with the API: \mylst{monitorNodeLimit(boolean b)}. The default value is set to \texttt{true}. Finally, you can get the node limit, once the solve method has been called, with the API: \mylst{getNodeCount()} 
\item[backtrack limit] State a backtrack limit on tree search. When the number of backtracks done is equal to the backtrack limit, the search stops whatever a solution is found or not. You can define a backtrack limit with the following API: \mylst{setBackTrackLimit(int backtrackLimit)} where unit is the number of backtracks. Or just monitor (or not) the number of backtrack done with the API: \mylst{monitorBackTrackLimit(boolean b)}. The default value is set to \texttt{false}. Finally, you can get the backtrack limit, once the solve method has been called, with the API: \mylst{getBackTrackCount()} 
\item[fail limit] State a fail limit on tree search. When the number of failure is equal to the fail limit, the search stops whatever a solution is found or not. You can define a fail limit with the following API : \mylst{setFailLimit(int failLimit)} where unit is the number of failure. Or just monitor (or not) the number of failure encountered with the API : \mylst{monitorFailLimit(boolean b)}. The default value is set to \texttt{false}. Finally, you can get the fail limit, once the solve method has been called, with the API : \mylst{getFailCount()} 
\item[CPU time limit] State a CPU limit on tree search. When the CPU time (user + system) is equal to the CPU time limit, the search stops whatever a solution is found or not. You can define a CPU time limit with the following API: \mylst{setCpuTimeLimit(int timeLimit)} where unit is millisecond. Or just monitor (or not) the search time with the API: \mylst{monitorCpuTimeLimit(boolean b)}. The default value is set to \texttt{false}. Finally, you can get the CPU time limit, once the solve method has been called, with the API: \mylst{getCpuTimeCount()} 
\end{description}

\todo{add example}

\section{Solve a problem}\label{solver:solveaproblem}\hypertarget{solver:solveaproblem}{}
As Solver is the second element of a Choco program, the control of the search process without using predefined tools is made on the Solver.

\noindent\begin{tabular}{p{.4\linewidth}p{.6\linewidth}}
  \hline
  \texttt{Solver} API & description \\
  \hline
      \mylst{solve()} &  Compute the first solution of the Model, if the Model is feasible. \\
      \mylst{solve(boolean all)} &  If \emph{all} is set to true, computes all solutions of the Model, if the Model is feasible. \\
      \mylst{solveAll()} &  Computes all the solution of the Model, if the Model is feasible. \\
      \mylst{propagate()} &  Computes initial propagation of the Model, and reachs the first Fix Point. It reduces variables Domain through constraints linked and other variables domain. Can throw a \texttt{ContradictionException} if the Solver detects a contradiction in the Model. \\
      \mylst{maximize(Var obj, boolean restart)} &  Allows user to find a solution that maximizing the objective varible \emph{obj}. The optimization finds a first solution then finds a new solution that improves \emph{obj} and so on till no other solution can be found that improves \emph{obj}. Parameter \emph{restart} is a boolean indicating whether the Solver will restart the search after each solution found (if set to \texttt{true}) or if it will keep backtracking from the leaf of the last solution found. See \hyperlink{solver:optimization}{example}. \textbf{Beware}: the variable \emph{obj} expected must be a Solver variable and not a Model variable. \\
      \mylst{minimize(Var obj, boolean restart)} &  Allows user to find a solution that minimizing the objective varible \emph{obj}. The optimization finds a first solution then finds a new solution that improves \emph{obj} and so on till no other solution can be found that improves \emph{obj}. Parameter \emph{restart} is a boolean indicating whether the Solver will restart the search after each solution found (if set to \texttt{true}) or if it will keep backtracking from the leaf of the last solution found. See \hyperlink{solver:optimization}{example}. \textbf{Beware}: the variable \emph{obj} expected must be a Solver variable and not a Model variable. \\
      \mylst{nextSolution()} &  Allows the Solver to find the next solution, if one or more solution have already been find with \texttt{solve()} or \texttt{nextSolution()}. \\
      \mylst{isFeasible()} &  Indicates whether or not the Model has at least one solution. \\
      \hline\\
	\end{tabular}

\subsection{Solver settings}\label{solver:solversettings}\hypertarget{solver:solversettings}{}

\subsubsection{Logs}\label{solver:logs}\hypertarget{solver:logs}{}
The solver class is instrumented in order to produce trace statements throughout search. The verbosity level of the solver can be set, by the following static method
\begin{lstlisting}
	CPSolver.setVerbosity(CPSolver.SEARCH);
	// And after solver.solve()
	CPSolver.flushLogs();
\end{lstlisting}

The code above ensure that messages are printed in order to describe the construction of the search tree.

Five verbosity levels are available:

\noindent\begin{tabular}{p{.4\linewidth}p{.6\linewidth}}
  \hline
  Level & prints... \\
  \hline
 \texttt{CPSolver.SILENT} & nothing\\
 \texttt{CPSolver.SOLUTION} & messages whenever a solution is reached\\
 \texttt{CPSolver.SEARCH} & a message at each choice point\\
 \texttt{CPSolver.PROPAGATION} & messages to trace propagation\\
 \texttt{CPSolver.FINEST} & high level messages to trace propagation\\
\hline\\
\end{tabular}

Note, that in the case of a verbosity set to \texttt{CPSolver.SEARCH}, trace statements are printed up to a maximal depth in the search tree. By default, only the 5 first levels are traced, but you can change the value of this threshold, say to 10, with the following setter method:
\begin{lstlisting}
  solver.setLoggingMaxDepth(10);
\end{lstlisting}

\subsection{Optimization}\label{solver:optimization}\hypertarget{solver:optimization}{}
\todo{to introduce}
\begin{lstlisting}
  Model m = new CPModel();
  IntegerVariable obj1 = makeEnumIntVar("obj1", 0, 7);
  IntegerVariable obj2 = makeEnumIntVar("obj1", 0, 5);
  IntegerVariable obj3 = makeEnumIntVar("obj1", 0, 3);
  IntegerVariable cost = makeBoundIntVar("cout", 0, 1000000);
  int capacity = 34;
  int[] volumes = new int[]{7, 5, 3};
  int[] energy = new int[]{6, 4, 2};
  // capacity constraint
  m.addConstraint(leq(scalar(volumes, new IntegerVariable[]{obj1, obj2, obj3}), capacity));
	
  // objective function
  m.addConstraint(eq(scalar(energy, new IntegerVariable[]{obj1, obj2, obj3}), cost));
  
  Solver s = new CPSolver();
  s.read(m);
  
  s.maximize(s.getVar(cost), false);
\end{lstlisting}
