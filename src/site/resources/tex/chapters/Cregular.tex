%\part{regular}
\label{regular}
\hypertarget{regular}{}

\section{regular (constraint)}\label{regular:regularconstraint}\hypertarget{regular:regularconstraint}{}
\begin{notedef}
  \texttt{regular}$(x,\mathcal{L}(\Pi))$ states that sequence $x$ is a word belonging to the regular language $\mathcal{L}(\Pi)$:
% recognized by a deterministic finite automaton (DFA) or a regular expression $\Pi$:
$$(x_1,\ldots,x_n)\in\mathcal{L}(\Pi)$$
\end{notedef}

The accepting language can be specified either by a deterministic finite automaton (DFA), a list of feasible or infeasible tuples, or a regular expression:
\begin{description}
\item[DFA:] Automaton $\Pi$ is defined on a given \emph{alphabet} $\Sigma\subseteq\Z$ by a set $Q=\{0,\ldots,m\}$ of \emph{states}, a subset $A\subseteq Q$ of \emph{final} or \emph{accepting states} and a table $\Delta\subseteq Q\!\times\!\Sigma\!\times Q$ of \emph{transitions} between states. $\Delta$ is encoded as \texttt{List<Transition>} where a Transition object $\delta=\texttt{new Transition}(q_i,\sigma,q_j)$ is made of three integers expressing the ingoing state $q_i$, the label $\sigma$, and the outgoing state $q_j$.
Automaton $\Pi$ is a DFA if $\Delta$ is finite and if it has only one initial state (here, state $0$ is considered as the unique initial state) and no two transitions sharing the same ingoing state and the same label.
\item[feasible tuples:] \emph{regular} can be used as an extensional constraint. Given the list of \emph{feasible} tuples for sequence $x$, this API builds a DFA from the list, and then enforces GAC on the constraint. Using \texttt{regular} can be more efficient than a standard GAC algorithm on tables of tuples if the tuples are structured so that the resulting DFA is compact. The DFA is built from the list of tuples by computing incrementally the minimal DFA after each addition of tuple. 
\item[infeasible tuples:] An another API allows to specify the list of \emph{infeasible} tuples and then builds the corresponding feasible DFA. This operation requires to know the entire alphabet, hence this API has two mandatory table fields \emph{min} and \emph{max} defining the minimum and maximum values of each variable $x_i$.
\item[regular expression:] Finally, the \texttt{regular} constraint can be based on a \href{http://en.wikipedia.org/wiki/regularexpression}{regular expression}, such as \mylst{String regexp = "(1}2)(3*)";| This expression recognizes any (possibly empty) sequences of 3 preceded by at least one 1 or one 2.
\end{description}

\begin{itemize}
	\item \textbf{API} :
	\begin{itemize}
		\item \mylst{regular(DFA pi, IntegerVariable[] x)}
		\item \mylst{regular(IntegerVariable[] x, List<int[]> feasTuples)}
		\item \mylst{regular(IntegerVariable[] x, List<int[]> infeasTuples, int[] min, int[] max)}
		\item \mylst{regular(String regexp, IntegerVariable[] x)}
	\end{itemize}
	\item \textbf{return type} : \texttt{Constraint}
	\item \textbf{options} :\emph{n/a}
	\item \textbf{favorite domain} : \emph{to complete}
	\item \textbf{references} :\\
       \cite{PesantCP04}: \emph{A regular language membership constraint}
\end{itemize}

\textbf{Examples}:
\begin{itemize}
	\item example 1 with DFA:
\end{itemize}

\begin{lstlisting}
  //1- Create the model
  Model m = new CPModel();
  int n = 6;
  IntegerVariable[] vars = new IntegerVariable[n];
  for (int i = 0; i < vars.length; i++) {
      vars[i] = makeIntVar("v" + i, 0, 5);
  }
  //2- Build the list of transitions of the DFA
  List<Transition> t = new LinkedList<Transition>();
  t.add(new Transition(0, 1, 1));
  t.add(new Transition(1, 1, 2));
  // transition with label 1 from state 2 to state 3 
  t.add(new Transition(2, 1, 3));
  t.add(new Transition(3, 3, 0));
  t.add(new Transition(0, 3, 0));
  
  //3- Two final states: 0, 3
  List<Integer> fs = new LinkedList<Integer>();
  fs.add(0); fs.add(3);
            
  //4- Build the DFA
  DFA auto = new DFA(t, fs, n);
  
  //5- add the constraint
  m.addConstraint(regular(auto, vars));
  
  //6- create the solver, read the model and solve it
  Solver s = new CPSolver();
  s.read(m);
  s.solve();
  do {
      for (int i = 0; i < n; i++)
      System.out.print(s.getVar(vars[i]).getVal());
      System.out.println("");
  } while (s.nextSolution());
  
  //7- Print the number of solution found
  System.out.println("Nb_sol : " + s.getNbSolutions());
\end{lstlisting}

\begin{itemize}
	\item example 2 with feasible tuples:
\end{itemize}

\begin{lstlisting}
  //1- Create the model
  Model m = new CPModel();
  IntegerVariable v1 = makeIntVar("v1", 1, 4);
  IntegerVariable v2 = makeIntVar("v2", 1, 4);
  IntegerVariable v3 = makeIntVar("v3", 1, 4);
	
  //2- add some allowed tuples (here, the tuples define a all_equal constraint)
  List<int[]> tuples = new LinkedList<int[]>();
  tuples.add(new int[]{1, 1, 1});
  tuples.add(new int[]{2, 2, 2});
  tuples.add(new int[]{3, 3, 3});
  tuples.add(new int[]{4, 4, 4});
	
  //3-  add the constraint
  m.addConstraint(regular(new IntegerVariable[]{v1, v2, v3}, tuples));
	
  //4- Create the solver, read the model and solve it
  Solver s = new CPSolver();	
  s.read(m);
  s.solve();
  do {
      System.out.println("("+s.getVar(v1)+","+s.getVar(v2)+","+s.getVar(v3)+")");
  } while (s.nextSolution());
	
  //5- Print the number of solution found
  System.out.println("Nb_sol : " + s.getNbSolutions());
\end{lstlisting}

\begin{itemize}
	\item example 3 with regular expression:
\end{itemize}

\begin{lstlisting}
  //1- Create the model
  Model m = new CPModel();
  int n = 6;
  IntegerVariable[] vars = makeIntVarArray("v", n, 0, 5);

  //2- add the constraint
  String regexp = "(1|2)(3*)(4|5)";
  m.addConstraint(regular(regexp, vars));
	
  //3- Create the solver, read the model and solve it
  Solver s = new CPSolver();
  s.read(m);
  s.solve();
  do {
      for (int i = 0; i < n; i++)
          System.out.print(s.getVar(vars[i]).getVal());
      System.out.println("");
  } while (s.nextSolution());
	
  //4- Print the number of solution found
  System.out.println("Nb_sol : " + s.getNbSolutions());
\end{lstlisting}
