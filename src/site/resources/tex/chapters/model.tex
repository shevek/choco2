\chapter{The model}\label{doc:model}\hypertarget{doc:model}{}

The Model, along with the Solver, is one of the two key elements of any Choco program. The Choco Model allows to describe a problem in an easy and declarative way: it simply records the variables and the constraints defining the problem.

This section describes the large API provided by Choco to create different types of \hyperlink{model:variables}{variables} and \hyperlink{model:constraints}{constraints}.

%\begin{note}
\textbf{Note that a static import is required to use the Choco API:}
\begin{lstlisting}
  import static choco.Choco.*;
\end{lstlisting}
%It is mandatory in order to compile !
%\end{note}

%\section{How to create a model}\label{model:howtocreateamodel}\hypertarget{model:howtocreateamodel}{}
First of all, a Model object is created as follows:
\begin{lstlisting}
Model model = new CPModel();
\end{lstlisting}
In that specific case, a Constraint Programming (CP) Model object has been created. 

\section{Variables}\label{model:variables}\hypertarget{model:variables}{}

%Choco provides a large API to create different types of variables : \textbf{integer}, \textbf{real} and \textbf{set}. 

A Variable is defined by a type (\hyperlink{integervariable}{integer}, \hyperlink{realvariable}{real}, or \hyperlink{setvariable}{set} variable), a name, and the values of its domain. When creating a simple variable, some options can be set to specify its domain representation (ex: enumerated or bounded) within the Solver.
%Some kinds of variables have options for their domain, it may have an effect on what kind of specific object is created when the model is read by the solver.
\begin{note}
The choice of the domain should be considered. The efficiency of the solver often depends on judicious choice of the domain type.
\end{note}
Variables can be combined as  \hyperlink{model:expressionvariables}{expression variables} using operators.

One or more variables can be added to the model using the following methods of the \texttt{Model} class:
\begin{lstlisting}
	model.addVariable(Variable... var);
	model.addVariable(String options, Variable... var);
\end{lstlisting} 
\subsubsection{Example} adding two variables to the model
\begin{lstlisting}
  model.addVariable(var1, var2);
\end{lstlisting}
\emph{options} allows to define the specific role of variables \emph{var}:  \hyperlink{model:decisionvariables}{decision/non-decision} variables or  \hyperlink{model:objectivevariable}{objective} variable.

\subsection{Simple Variables}\label{model:simplevariables}\hypertarget{model:simplevariables}{}
See Section \hyperlink{ch:vars}{Variables} for details:
\begin{notedef}
\hyperlink{integervariable}{IntegerVariable}, \hyperlink{setvariable}{SetVariable}, \hyperlink{realvariable}{RealVariable}
\end{notedef}


\subsection{Expression variables and operators}\label{model:expressionvariables}\hypertarget{model:expressionvariables}{}
Expression variables represent the result of combinations between variables of the same type made by operators. Three types of expression variables exist : 
\begin{notedef}
\textbf{\tt IntegerExpressionVariable}, \textbf{\tt SetExpressionVariable}, and \textbf{\tt RealExpressionVariable}.
\end{notedef}
One can define a buffered expression variable to make a constraint easy to read, for example:
\begin{lstlisting}
	IntegerVariable v1 = makeIntVar("v1", 1, 3);
	IntegerVariable v2 = makeIntVar("v2", 1, 3);
	IntegerExpressionVariable v1Andv2 = plus(v1, v2);
\end{lstlisting}

%\section{Operators}\label{model:operators}\hypertarget{model:operators}{}

To construct expressions of variables, simple operators can be used. Each returns a \texttt{ExpressionVariable} object:
\begin{notedef}
\hyperlink{abs:absoperator}{abs}, \hyperlink{cos:cosoperator}{cos}, \hyperlink{div:divoperator}{div}, \hyperlink{false:falseoperator}{FALSE}, \hyperlink{max:maxoperator}{max}, \hyperlink{min:minoperator}{min}, \hyperlink{minus:minusoperator}{minus}, \hyperlink{mod:modoperator}{mod}, \hyperlink{mult:multoperator}{mult}, \hyperlink{neg:negoperator}{neg}, \hyperlink{plus:plusoperator}{plus}, \hyperlink{power:poweroperator}{power}\hyperlink{scalar:scalaroperator}{scalar}, \hyperlink{sin:sinoperator}{sin}, \hyperlink{sum:sumoperator}{sum}, \hyperlink{true:trueoperator}{TRUE}.
\end{notedef}
Note that these operators are not considered as constraints: they do not return a \texttt{Constraint} objet but a \texttt{Variable} object.

\subsection{Constant variables}\label{model:constantvariables}\hypertarget{model:constantvariables}{}
\emph{Under development}

\subsection{Decision/non-decision variables}\label{model:decisionvariables}\hypertarget{model:decisionvariables}{}

Once all the variables of the problem has been declared, it is possible to specify which variables are decision variables or non-decision variables. It can be done when adding the variables to the Model, by setting the option to \texttt{cp:decision} or \texttt{cp:no\_decision}.
\begin{lstlisting}
  IntegerVariable toto = Choco.makeIntVar("toto", 1, 2, CPOptions.V_DECISION); // decision variable
  IntegerVariable titi = Choco.makeIntVar("titi", 1, 2, CPOptions.V_NO_DECISION); // non-decision
\end{lstlisting}
Each of these options can also be set within a single instruction for a group of variables, as follows: 
\begin{lstlisting}
	IntegerVariable toto = Choco.makeIntVar("toto", 1, 2);
	IntegerVariable titi = Choco.makeIntVar("titi", 1, 2);
	model.addVariable(CPOptions.V_DECISION,toto, titi);
\end{lstlisting}
These options are useful when:
\begin{itemize}
	\item one knows which variables are decision or non-decision ones
	\item one does not want some variables to be in the search strategy (then set \texttt{cp:no\_decision})
	\item one does not want to deal with a specialized search strategy
\end{itemize}
A \texttt{default} search strategy will be created on the decision variables. 
\begin{note}
  \begin{itemize}
  \item The declaration of a user-defined \hyperlink{solver:searchstrategy}{search strategy} will erase setting \texttt{CPOptions.V_DECISION}.
  \item The declaration of a \hyperlink{solver:searchstrategy}{search strategy} will erase setting \texttt{cp:no\_decision}.
  \end{itemize}
\end{note}
  \todo{more precise: user-defined/pre-defined, variable and/or value heuristics ?}

\subsection{Objective variable}\label{model:objectivevariable}\hypertarget{model:objectivevariable}{}
You can define an objective variable directly within the model, by using option \texttt{CPOptions.V_OBJECTIVE}:
\begin{lstlisting}
	Model m = new CPModel();
	Solver s = new CPSolver();
	IntegerVariable x = makeIntVar("x", 1, 1000, CPOptions.V_OBJECTIVE);
	IntegerVariable y = makeIntVar("y", 20, 50);
	m.addConstraint(eq(x, mult(y, 20)));
	s.read(m);
	s.minimize(true);
\end{lstlisting}

Only one variable can be defined as an objective. If more than one objective variable is declared, then only the last one will be taken into account.

Note that optimization problems can be declared without defining an objective variable within the model (see the \hyperlink{solver:optimization}{optimization example}.)

\subsection{Examples with variables}\label{model:exampleswithvariables}\hypertarget{model:exampleswithvariables}{}
\begin{lstlisting}
	Model m = new CPModel();
	
	// Bounded integer variables
	IntegerVariable biv = makeIntVar("biv", 1, 10000, CPOptions.V_BOUND);
	IntegerVariable[][] biVars = makeIntVarArray("biVars", 20, 30, 1, 99999, CPOptions.V_BOUND);
	m.addVariable(biv);
	for(int i = 0; i < biVars.length; i++){
	  m.addVariable(biVars[i]);
	}
	
	// Enumerated integer variables
	IntegerVariable eiv = makeIntVar("eiv", 1, 100, CPOptions.V_ENUM);
	IntegerVariable[] eiVars = makeIntVarArray("eiVars", 10, 1, 50, CPOptions.V_ENUM);
	int[] values1 = new int[]{1,3,5,7,14,16,18,24,46,78, 99};
	IntegerVariable eiv2 = makeIntVar("eiv2", values,CPOptions.V_ENUM);
	m.addVariable(eiv, eiv2);
	m.addVariable(eiVars);
	
	// Linked list integer variables
	IntegeVariable lliv = makeIntVar("lliv", 1, 10, CPOptions.V_LINK);
	int[] values2 = new int[]{1,3,5,7,14,16,18,24,46,78, 99};
	IntegeVariable lliv2 = makeIntVar("lliv2", values2, CPOptions.V_LINK);
	m.addVariable(lliv, lliv2);
	
	IntegerExpressionVariable iev = plus(lliv, 1);
	m.addVariable(iev);
	
	// Bounded set variable
	SetVariable bsv = makeSetVar("bsv", 1, 24, CPOptions.V_ENUM);
	SetVariable bsv2 = makeSetVar("bsv2", 1, 36, CPOptions.V_BOUND);
	
	// Enumerated set variable
	SetVariable esv = makeSetVar("bsv", 1, 240,CPOptions.V_ENUM);
	
	m.addVariable(bsv, bs2, esv);
	
	// Real variable
	RealVariable rv = makeRealVar("rv", -1.0, 1.0);
	RealVariable rv2 = makeRealVar("rv", -8.77, 9.87);
	RealExpressionVariable rev = plus(cos(rv), power(rv2, 2));
	m.addVariable(rv, rv2, rev);
\end{lstlisting}

\section{Constraints}\label{model:constraints}\hypertarget{model:constraints}{}
Choco provides a large number of simple and global constraints and allows the user to easily define its own new constraint.
% Either basic, global (a \hyperlink{constraints}{large set of global constraints} are available) or \hyperlink{advanced:defineyourownconstraint}{user-defined} constraints, they are used to specify conditions to be held on variables to the model. 
A constraint deals with one or more variables of the model and specify conditions to be held on these variables. 
A constraint is stated into the model by using the following methods available from the \texttt{Model} API: 
\begin{lstlisting}
	addConstraint(Constraint... c);
	addConstraint(String options, Constraint... c);
\end{lstlisting} 
\subsubsection{Example}: adding a difference (disequality) constraint between two variables of the model
\begin{lstlisting}
model.addConstraint(neq(var1, var2));
\end{lstlisting}
Available \emph{options} depend on the kind of constraint \emph{c} to add: they allow, for example, to choose the filtering algorithm to run during propagation. These are strings prefixed with \texttt{cp:}, such as \texttt{"cp:decomp"} or \texttt{"cp:ac"}.

This section presents the constraints available in the Choco API sorted by type or by domain. Related sections:
\begin{itemize}
\item a detailed description (with options, examples, references) of each constraint is given in Section \hyperlink{ch:constraints}{constraints}
\item Section \hyperlink{doc:applications}{applications} shows how to apply some specific global constraints
\item Section \hyperlink{advanced:defineyourownconstraint}{user-defined constraint} explains how to create its own constraint.
\end{itemize}



\subsection{Binary constraints}\label{model:comparisonconstraints}\hypertarget{model:comparisonconstraints}{}
%The simplest constraints are comparisons which are defined over expressions of variables such as linear combinations. The following comparison constraints can be accessed through the \texttt{Model} API:
Constraints involving two integer variables
\begin{notedef}\tt
  \begin{itemize}
  \item \hyperlink{eq:eqconstraint}{eq}, \hyperlink{geq:geqconstraint}{geq}, \hyperlink{gt:gtconstraint}{gt}, \hyperlink{leq:leqconstraint}{leq}, \hyperlink{lt:ltconstraint}{lt}, \hyperlink{neq:neqconstraint}{neq}
  \item \hyperlink{abs:absconstraint}{abs}, \hyperlink{oppositesign:oppositesignconstraint}{oppositeSign}, \hyperlink{samesign:samesignconstraint}{sameSign}
  \end{itemize}
\end{notedef}

\subsection{Ternary constraints}\label{model:ternaryconstraints}\hypertarget{model:ternaryconstraints}{}
Constraints involving three integer variables
\begin{notedef}\tt
  \begin{itemize}
  \item \hyperlink{distanceeq:distanceeqconstraint}{distanceEQ}, \hyperlink{distanceneq:distanceneqconstraint}{distanceNEQ}, \hyperlink{distancegt:distancegtconstraint}{distanceGT}, \hyperlink{distancelt:distanceltconstraint}{distanceLT}
  \item \hyperlink{intdiv:intdivconstraint}{intDiv}, \hyperlink{mod:modconstraint}{mod}, \hyperlink{times:timesconstraint}{times}
  \end{itemize}
\end{notedef}

\subsection{Constraints involving real variables}\label{model:realconstraints}\hypertarget{model:realconstraints}{}
%The simplest constraints are comparisons which are defined over expressions of variables such as linear combinations. The following comparison constraints can be accessed through the \texttt{Model} API:
Constraints involving two real variables
\begin{notedef}\tt
  \begin{itemize}
  \item \hyperlink{eq:eqconstraint}{eq}, \hyperlink{geq:geqconstraint}{geq}, \hyperlink{leq:leqconstraint}{leq}
  \end{itemize}
\end{notedef}

\subsection{Constraints involving set variables}\label{model:setconstraints}\hypertarget{model:setconstraints}{}
%The simplest constraints are comparisons which are defined over expressions of variables such as linear combinations. The following comparison constraints can be accessed through the \texttt{Model} API:
Set constraints are illustrated on the \hyperlink{model:example2:ternarysteinerchoco}{ternary Steiner problem}. 
\begin{notedef}\tt
  \begin{itemize}
  \item \hyperlink{eqcard:eqcardconstraint}{eqCard}, \hyperlink{geqcard:geqcardconstraint}{geqCard}, \hyperlink{leqcard:leqcardconstraint}{leqCard}
  \item \hyperlink{member:memberconstraint}{member}, \hyperlink{notmember:notmemberconstraint}{notMember}
  \item \hyperlink{isincluded:isincludedconstraint}{isIncluded}, \hyperlink{isnotincluded:isnotincludedconstraint}{isNotIncluded}, \hyperlink{setdisjoint:setdisjointconstraint}{setDisjoint}
  \item \hyperlink{setinter:setinterconstraint}{setInter}, \hyperlink{setunion:setunionconstraint}{setUnion}
  \item \hyperlink{max:maxofaset}{max}, \hyperlink{min:minofaset}{min}
  \item \hyperlink{pack:packconstraint}{pack}
  \end{itemize}
\end{notedef}

%\hyperlink{max:maxconstraint}{max}, \hyperlink{min:minconstraint}{min},

\subsection{Channeling constraints}\label{model:channelingconstraints}\hypertarget{model:channelingconstraints}{}
The use of a redundant model is a frequent technique to strengthen propagation or to get more freedom to design dedicated search heuristics. The following constraints allow to ensure integrity of different models:
\begin{notedef}\tt
  \begin{itemize}
  \item \hyperlink{inversechanneling:inversechannelingconstraint}{inverseChanneling}, \hyperlink{boolchanneling:boolchannelingconstraint}{boolChanneling}
  \end{itemize}
\end{notedef}
More complex channeling can be done using reified constraints (see Section \hyperlink{model:reifiedconstraints}{reification}) although they are less efficient. For example, to ensure that two variables are equal or not, one can reify the equality into a boolean variables :
\begin{lstlisting}
	IntegerVariable reifiedB = makeIntVar("bvar", 0, 1);
	IntegerVariable x = makeIntVar("a", 0, 10);
	IntegerVariable y = makeIntVar("b", 0, 10);
	model.addConstraint(reifiedIntConstraint(reifiedB, eq(x, y)));
\end{lstlisting}

\subsection{Constraints in extension and relations}\label{model:arbitraryconstraintsinextension}\hypertarget{model:arbitraryconstraintsinextension}{}
Choco supports the statement of constraints defining arbitrary relations over two or more variables.
Such a relation may be defined by three means:
\begin{itemize}
	\item \textbf{feasible table:} the list of allowed tuples of values (that belong to the relation),
	\item \textbf{infeasible table:} the list of forbidden tuples of values (that do not belong to the relation),
	\item \textbf{predicate:} a method to be called in order to check whether a tuple of values belongs or not to the relation.
\end{itemize}
On the one hand, constraints based on tables may be rather memory consuming in case of large domains, although one relation table may be shared by several constraints. On the other hand, predicate constraints require little memory as they do not cache truth values, but imply some run-time overhead for calling the feasibility test. Table constraints are thus well suited for constraints over small domains; while predicate constraints are well suited for situations with large domains. 

Different levels of consistency can be enforce on constraints in extension: 
\begin{itemize}
\item several arc-consistency (AC) algorithms for binary relations
\item two AC algorithms for n-ary relations dedicated either to positive or to negative tables (relation defined by the allowed or forbidden tuples)
\item a weaker forward-checking (FC) algorithm for n-ary relations.
\end{itemize}

The Choco API for creating constraints in extension are as follows:
\begin{notedef}\tt
  \begin{itemize}
  \item \hyperlink{feaspairac:feaspairacconstraint}{feasPairAC}, \hyperlink{infeaspairac:infeaspairacconstraint}{infeasPairAC}, \hyperlink{relationpairac:relationpairacconstraint}{relationPairAC}
  \item \hyperlink{feastupleac:feastupleacconstraint}{feasTupleAC}, \hyperlink{infeastupleac:infeastupleacconstraint}{infeasTupleAC}, \hyperlink{relationtupleac:relationtupleacconstraint}{relationTupleAC}
  \item \hyperlink{feastuplefc:feastuplefcconstraint}{feasTupleFC}, \hyperlink{infeastuplefc:infeastuplefcconstraint}{infeasTupleFC}, \hyperlink{relationtuplefc:relationtuplefcconstraint}{relationTupleFC}
  \end{itemize}
\end{notedef}

\subsubsection{Relations.}
A same relation might be shared among several constraints, in this case it is highly recommended to create it first and then use the \hyperlink{relationpairac:relationpairacconstraint}{relationPairAC}, \hyperlink{relationtupleac:relationtupleacconstraint}{relationTupleAC}, or \hyperlink{relationtuplefc:relationtuplefcconstraint}{relationTupleFC} API  on the same relation for each constraint.

For binary relations, the following Choco API is provided:
\begin{lstlisting}
  makeBinRelation(int[] min, int[] max, List<int[]>pairs, boolean feas);
\end{lstlisting}
It returns a \texttt{BinRelation} giving a list of compatible (\texttt{feas=true}) or incompatible (\texttt{feas=false}) pairs of values. This relation can be applied to any pair of variables $(x_1,x_2)$ whose domains are included in the \texttt{min/max} intervals, i.e. such that:
$$\mathtt{min}[i] \le x_i.\mathtt{getInf}() \le x_i.\mathtt{getSup}() \le  \mathtt{max}[i],\quad \forall i.$$
Bounds \texttt{min/max} are mandatory in order to allow to compute the opposite of the relation if needed.

For n-ary relations, the corresponding Choco API is:
\begin{lstlisting}
  makeLargeRelation(int[] min, int[] max, List<int[]> tuples, boolean feas);
\end{lstlisting}
It returns a \texttt{LargeRelation}. If \texttt{feas=true}, the returned relation matches also the \texttt{IterLargeRelation} interface which provides constant time iteration abilities over tuples (for compatibility with the GAC algorithm used over feasible tuples).
\begin{lstlisting}
  LargeRelation r = makeLargeRelation(min, max, tuples, true);
  model.addConstraint(relationTupleAC(vars, r));
\end{lstlisting}

Lastly, some specific relations can be defined without storing the tuples, as in the following example (\texttt{TuplesTest} extends \texttt{LargeRelation}):
\begin{lstlisting}
  public class NotAllEqual extends TuplesTest {
      public boolean checkTuple(int[] tuple) {
          for (int i = 1; i < tuple.length; i++) {
              if (tuple[i - 1] != tuple[i]) return true;
          }
          return false;
      }
  }
\end{lstlisting}
Then, a \emph{NotAllEqual} constraint can be stated within the problem by:
\begin{lstlisting}
  model.addConstraint(relationTupleFC(new IntegerVariable[]{x, y, z}, new NotAllEqual()));
\end{lstlisting}
%Again, for compatibility with the GAC algorithm invoked by relationTupleAC, such a relation has to match the \texttt{IterLargeRelation} interface for feasible tuples.



%\subsection{Expression and Reified constraints}\label{model:expressionandreifiedconstraints}\hypertarget{model:expressionandreifiedconstraints}{}

\subsection{Reified constraints}\label{model:reifiedconstraints}\hypertarget{model:reifiedconstraints}{}
Constraints involved in another constraint are usually called reified constraints. Typical examples of reified constraints are
 constraints combined with logical operators, such as $(x \neq y) \lor (z \le 9)$.

%\subsubsection{To reify a constraint into a boolean variable.}\label{model:toreifyaconstraintintoabooleanvariable}\hypertarget{model:toreifyaconstraintintoabooleanvariable}{}
Choco provides a generic constraint to reify any constraints on integer variables into a boolean variable expressing its truth value:
\begin{notedef}\tt
  \begin{itemize}
  \item \hyperlink{reifiedintconstraint:reifiedintconstraintconstraint}{reifiedIntConstraint}
  \end{itemize}
\end{notedef}
This mechanism can be used for example to model MaxCSP problems where the number of satisfied constraints has to be maximized.
It is also intended to give the freedom to the user to build complex reified constraints. However, Choco provides a more simple and direct API to build complex expressions using boolean operators:
\begin{notedef}\tt
  \begin{itemize}
  \item \hyperlink{and:andconstraint}{and}, \hyperlink{or:orconstraint}{or}, \hyperlink{implies:impliesconstraint}{implies}, \hyperlink{ifonlyif:ifonlyifconstraint}{ifOnlyIf}, \hyperlink{ifthenelse:ifthenelseconstraint}{ifThenElse}, \hyperlink{not:notconstraint}{not}
  \end{itemize}
\end{notedef}
Such an expression is represented as a tree of operators. The leaves of this tree are made of variables, constants or even traditional constraints. Variables and constants can be combined as \texttt{ExpressionVariable} using \hyperlink{model:expressionvariables}{operators} (e.g, \texttt{mult(10,abs(w))}), or using simple constraints (e.g., \texttt{leq(z,9)}), or even using global constraints (e.g, \texttt{alldifferent(vars)}).
The language available on expressions is therefore slightly richer and matches the language used in the \href{http://cpai.ucc.ie/08/}{Constraint Solver Competition 2008} of the CPAI workshop.

For example, the following expression
$$((x = 10 * |y|) \lor (z \le 9))\quad \iff\quad \texttt{alldifferent}(a,b,c)$$
could be represented by :
\begin{lstlisting}
	Constraint exp = ifOnlyIf( or( eq(x, mult(10, abs(y))), leq(z, 9) ), 
                               alldifferent(new IntegerVariable[]{a,b,c}) );
\end{lstlisting}

%Global constraints can also be embedded in an expression. 
%Consider for example expression:
%$$((x \neq y) \lor (z \le 9)) \quad\iff\quad \texttt{alldifferent}(a,b,c).$$
%It could be represented by :
%\begin{lstlisting}
%	IntegerVariable[] tabv = new IntegerVariable[]{a,b,c};
%	Constraint exp = ifOnlyIf( or( neq(z, y), leq(z, 9) ), alldifferent(tabv) );
%\end{lstlisting}

%The complete example below shows how to declare expression:
%$$(z = 10 * |w|)\lor(z\le 9)$$
%\begin{lstlisting}
%	Model m = new CPModel();
%	IntegerVariable z = makeIntVar("z", -10, 10);
%	IntegerVariable w = makeIntVar("w", -10, 10);
%	m.addVariable(z, w);
	
%	// z = 10 * |w| OR z <= 9
%	Constraint exp = or( eq(z, mult(10, abs(w))), leq(z, 9));
%	m.addConstraint(exp);
%\end{lstlisting}

\subsubsection{Handling complex expressions.}\label{model:handlingcomplexexpressions}\hypertarget{model:handlingcomplexexpressions}{}
Expressions offer a more powerful modeling language than the one available via standard constraints. However, they 
can not be handled as efficiently as the standard constraints that embed a dedicated propagation algorithm. We therefore
recommend you to carefully check that you can not model the expression using the intensional constraints of Choco before using
expressions.
Inside the solver, expressions can be represented in two different ways that can be decided at the modeling level, using the following Model API:
\begin{lstlisting}
  setDefaultExpressionDecomposition(boolean decomp);
\end{lstlisting}
\begin{itemize}
\item The first way (\texttt{decomp=false}) is to handle them as \hyperlink{model:arbitraryconstraintsinextension}{constraints in extension}. The expression is then used to check a tuple in a dynamic way just like a n-ary relation that is defined without listing all the possible tuples. The expression is then propagated using the GAC3rm algorithm. This is very powerful as arc-consistency is obtained on the corresponding constraints.
\item The second way (\texttt{decomp=true}) is to decompose the expression automatically by introducing intermediate variables and eventually the generic \hyperlink{reifiedintconstraint:reifiedintconstraintconstraint}{\tt reifiedIntConstraint}. By doing so, the level of pruning decreases but expressions of larger arity involving large domains can be represented.
\end{itemize}

%\subsubsection{Tell the solver how to consider an expression.}
%The default representation of expressions can be enforced using the following API  on the model object: 
%Parameter \emph{decomp} tells the solver whether expressions shoud be considered as extensional constraints (\texttt{decomp=false}) or decomposed 
Once the default representation is chosen, one can also make exception for a particular expression using options on \texttt{addConstraint}. 
For example, the following code tells the solver to decompose e1 and not e2 :
\begin{lstlisting}
	model.setDefaultExpressionDecomposition(false);
	IntegerVariable x = makeIntVar("x", 1, 3, CPOptions.V_BOUND);
	IntegerVariable y = makeIntVar("y", 1, 3, CPOptions.V_BOUND);
	IntegerVariable z = makeIntVar("z", 1, 3, CPOptions.V_BOUND);

	Constraint e1 = or(lt(x, y), lt(y, x));
	model.addConstraint(CPOptions.E_DECOMP, e1);
	
	Constraint e2 = or(lt(y, z), lt(z, y));
	model.addConstraint(e2);
\end{lstlisting}

\subsubsection{When and how should I use expressions ?}\label{model:whenshouldiuseexpressions}\hypertarget{model:whenshouldiuseexpressions}{}
An expression (represented in extension) should be used in the case of a complex logical relationship that involves \textbf{few different variables}, each of \textbf{small domain}, and if \textbf{arc consistency} is desired on those variables.
In such a case, an expression can even be more powerful than a model using intermediate variables and intensional constraints.
Imagine the following ``crazy'' example :
\begin{lstlisting}
 or( and( eq( abs(sub(div(x,50),div(y,50))),1), eq( abs(sub(mod(x,50),mod(y,50))),2)),
     and( eq( abs(sub(div(x,50),div(y,50))),2), eq( abs(sub(mod(x,50),mod(y,50))),1)))
\end{lstlisting}
This expression has a small arity: it involves only two variables $x$ and $y$.
Let assume that their domains has no more than 300 values, then such an expression should typically not be decomposed. Indeed, arc consistency will create many holes in the domains and filter much more than if the relation was decomposed.

Conversely, an expression should be decomposed as soon as it involves a large number of variables, or at least one variable with a large domain.

\subsection{Global constraints}\label{model:advancedconstraints}\hypertarget{model:advancedconstraints}{}
Choco includes several \href{http://www.emn.fr/x-info/sdemasse/gccat/}{global constraints}, such as:
\begin{notedef}\tt
\hyperlink{alldifferent:alldifferentconstraint}{allDifferent}, 
\hyperlink{globalcardinality:globalcardinalityconstraint}{globalCardinality}, 
\hyperlink{atmostnvalue:atmostnvalueconstraint}{atMostNValue},
\hyperlink{cumulative:cumulativeconstraint}{cumulative}, 
\hyperlink{lex:lexconstraint}{lex}, 
\hyperlink{regular:regularconstraint}{regular},
 \hyperlink{tree:treeconstraint}{tree},
\hyperlink{geost:geostconstraint}{geost}, etc.
\end{notedef}
Those constraints offer dedicated filtering algorithms which are able to make deductions where a decomposed model would not.
For instance, constraint \texttt{alldifferent}$(a,b,c,d)$ with $a,b\in[1,4]$ and $c,d\in[3,4]$ allows to deduce that $a$ and $b$ cannot be instantiated to $3$ or $4$; such rule cannot be inferred by simple binary constraints. 

The up-to-date list of global constraints available in Choco can be found within the Javadoc API.
Most of these global constraints are also described in Section \hyperlink{ch:constraints}{Constraints}.

\subsection{Scheduling constraints}\label{model:schedulingconstraints}\hypertarget{model:schedulingconstraints}{}
See also \hyperlink{schedulinganduseofthecumulative:schedulinganduseofthecumulativeconstraint}{scheduling application}.
\begin{notedef}\tt
\hyperlink{cumulative:cumulativeconstraint}{cumulative}, \hyperlink{disjunctive:disjunctiveconstraint}{disjunctive}, \hyperlink{geost:geostconstraint}{geost}, \hyperlink{pack:packconstraint}{pack}, \hyperlink{preceding:precedingconstraint}{preceding}, \hyperlink{precedencereified:precedencereifiedconstraint}{precedenceReified}.
\end{notedef}

\subsection{Sequencing constraints}\label{model:theregularconstraint}\hypertarget{model:theregularconstraint}{}
\begin{notedef}\tt
  \hyperlink{multicostregular:multicostregularconstraint}{multiCostRegular}, \hyperlink{regular:regularconstraint}{regular}, \hyperlink{stretchcyclic:stretchcyclicconstraint}{stretchCyclic}, \hyperlink{stretchpath:stretchpathconstraint}{stretchPath}, 
\end{notedef}

