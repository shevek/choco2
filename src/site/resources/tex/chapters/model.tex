\chapter{The model}\label{doc:model}\hypertarget{doc:model}{}

The {\tt Model}, along with the {\tt Solver}, is one of the two key elements of any Choco program. The Choco {\tt Model} allows to describe a problem in an easy and declarative way: it simply records the variables and the constraints defining the problem.

This section describes the large API provided by Choco to create different types of \hyperlink{model:variables}{variables} and \hyperlink{model:constraints}{constraints}.

%\begin{note}
\textbf{Note that a static import is required to use the Choco API:}
\begin{lstlisting}
  import static choco.Choco.*;
\end{lstlisting}
%It is mandatory in order to compile !
%\end{note}

%\section{How to create a model}\label{model:howtocreateamodel}\hypertarget{model:howtocreateamodel}{}
First of all, a {\tt Model} object is created as follows:
\begin{lstlisting}
Model model = new CPModel();
\end{lstlisting}
In that specific case, a Constraint Programming (CP) {\tt Model} object has been created. 


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% VARIABLE %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Variables}\label{model:variables}\hypertarget{model:variables}{}

%Choco provides a large API to create different types of variables : \textbf{integer}, \textbf{real} and \textbf{set}. 

A Variable is defined by a type (\hyperlink{integervariable}{integer}, \hyperlink{realvariable}{real}, or \hyperlink{setvariable}{set} variable), a name, and the values of its domain. When creating a simple variable, some options can be set to specify its domain representation (ex: enumerated or bounded) within the {\tt Solver}.
%Some kinds of variables have options for their domain, it may have an effect on what kind of specific object is created when the model is read by the solver.
\begin{note}
The choice of the domain should be considered. The efficiency of the solver often depends on judicious choice of the domain type.
\end{note}
Variables can be combined as \hyperlink{model:expressionvariables}{expression variables} using operators.

One or more variables can be added to the model using the following methods of the \texttt{Model} class:
\lstinputlisting{java/mvariabledeclaration1.j2t}

\begin{note}
Explictly addition of variables is not mandatory. See \hyperlink{model:constraints}{\tt Constraint} for more details.
\end{note}

Specific role of variables \emph{var} can be defined with \emph{options}:  \hyperlink{model:decisionvariables}{non-decision} variables or  \hyperlink{model:objectivevariable}{objective} variable;
\lstinputlisting{java/mvariabledeclaration2.j2t}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% SIMPLE VARIABLE  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Simple Variables}\label{model:simplevariables}\hypertarget{model:simplevariables}{}
See Section \hyperlink{ch:vars}{Variables} for details:
\begin{notedef}\tt
\hyperlink{integervariable}{IntegerVariable}, \hyperlink{setvariable}{SetVariable}, \hyperlink{realvariable}{RealVariable}
\end{notedef}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% CONSTANT VARIABLE  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Constants}\label{model:constants}\hypertarget{model:constants}{}
A constant is a variable with a fixed domain. \hyperlink{integervariable}{\tt IntegerVariable} declared with a unique value are automatically set as constant. A constant declared twice or more is only stored once in a model.

\lstinputlisting{java/mconstant.j2t}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% EXPRESSION VARIABLE  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsection{Expression variables and operators}\label{model:expressionvariables}\hypertarget{model:expressionvariables}{}
Expression variables represent the result of combinations between variables of the same type made by operators. Two types of expression variables exist : 
\begin{notedef}
\textbf{\tt IntegerExpressionVariable} and \textbf{\tt RealExpressionVariable}.
\end{notedef}
One can define a buffered expression variable to make a constraint easy to read, for example:
\lstinputlisting{java/mexpressionvariable.j2t}

%\section{Operators}\label{model:operators}\hypertarget{model:operators}{}

To construct expressions of variables, simple operators can be used. Each returns a \texttt{ExpressionVariable} object:
\begin{notedef}\tt
\hyperlink{abs:absoperator}{abs}, \hyperlink{cos:cosoperator}{cos}, \hyperlink{disteq:disteqoperator}{distEq}, \hyperlink{distgt:distgtoperator}{distGt}, \hyperlink{distlt:distltoperator}{distLt}, \hyperlink{distneq:distneqoperator}{distNeq}, \hyperlink{div:divoperator}{div}, \hyperlink{ifthenelse:ifthenelseoperator}{ifThenElse}, \hyperlink{max:maxoperator}{max}, \hyperlink{min:minoperator}{min}, \hyperlink{minus:minusoperator}{minus}, \hyperlink{mod:modoperator}{mod}, \hyperlink{mult:multoperator}{mult}, \hyperlink{neg:negoperator}{neg}, \hyperlink{plus:plusoperator}{plus}, \hyperlink{power:poweroperator}{power}, \hyperlink{scalar:scalaroperator}{scalar}, \hyperlink{sin:sinoperator}{sin}, \hyperlink{sum:sumoperator}{sum}.
\end{notedef}
Note that these operators are not considered as constraints: they do not return a \texttt{Constraint} objet but a \texttt{Variable} object.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% MULTIPLE VARIABLE  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{MultipleVariables}\label{model:multiplevariables}\hypertarget{model:multiplevariables}{}
These are syntaxic sugar. To make their declaration easier, \hyperlink{tree:treeconstraint}{\tt tree}, \hyperlink{geost:geostconstraint}{\tt geost} and scheduling constraints require to use {\tt MultipleVariables}, like \texttt{TreeParametersObject}, \texttt{GeostObject} or \hyperlink{taskvariable}{\tt TaskVariable}.

  \todo{link to an example of user-defined MultipleVariables}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% OPTIONS %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Decision/non-decision variables}\label{model:decisionvariables}\hypertarget{model:decisionvariables}{}

By default, each variable added to a model is a decision variable, \textit{i.e.} is included in the default search strategy. A variable can be stated as a non decision one if its value can be computed by side-effect. To specify non decision variables, one can 
\begin{itemize}
\item exclude them from its search strategies (see \hyperlink{solver:searchstrategy}{search strategy} for more details);
\item specify non-decision variables (adding \hyperlink{vnodecision:vnodecisionoptions}{\tt Options.V\_NO\_DECISION} to their options) and keep the default search strategy.
\end{itemize}
\lstinputlisting{java/mnodecision1.j2t}
Each of these options can also be set within a single instruction for a group of variables, as follows: 
\lstinputlisting{java/mnodecision2.j2t}

\begin{note}
  \begin{itemize}
  \item The declaration of a \hyperlink{solver:searchstrategy}{search strategy} will erase setting \hyperlink{vnodecision:vnodecisionoptions}{\tt Options.V\_NO\_DECISION}.
  \end{itemize}
\end{note}
  \todo{more precise: user-defined/pre-defined, variable and/or value heuristics ?}

\subsection{Objective variable}\label{model:objectivevariable}\hypertarget{model:objectivevariable}{}
You can define an objective variable directly within the model, by using option \hyperlink{vobjective:vobjectiveoptions}{\tt Options.V\_OBJECTIVE}:
\lstinputlisting{java/mobjective.j2t}

Only one variable can be defined as an objective. If more than one objective variable is declared, then only the last one will be taken into account.

Note that optimization problems can be declared without defining an objective variable within the model (see the \hyperlink{solver:optimization}{optimization example}.)

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% CONSTRAINT  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Constraints}\label{model:constraints}\hypertarget{model:constraints}{}
Choco provides a large number of simple and global constraints and allows the user to easily define its own new constraint.
% Either basic, global (a \hyperlink{constraints}{large set of global constraints} are available) or \hyperlink{advanced:defineyourownconstraint}{user-defined} constraints, they are used to specify conditions to be held on variables to the model. 
A constraint deals with one or more variables of the model and specify conditions to be held on these variables. 
A constraint is stated into the model by using the following methods available from the \texttt{Model} API: 

\lstinputlisting{java/mconstraintdeclaration1.j2t}

\begin{notedef}\
Adding a constraint automatically adds its variables to the model (explicit declaration of variables addition is not mandatory).
\end{notedef}


\subsubsection{Example:} adding a difference (disequality) constraint between two variables of the model

\lstinputlisting{java/mconstraintdeclaration2.j2t}

Available \emph{options} depend on the kind of constraint \emph{c} to add: they allow, for example, to choose the filtering algorithm to run during propagation. See \hyperlink{optionssettings}{Section options ans settings} for more details, specific APIs exist for declaring options constraints.

This section presents the constraints available in the Choco API sorted by type or by domain. Related sections:
\begin{itemize}
\item a detailed description (with options, examples, references) of each constraint is given in Section \hyperlink{ch:constraints}{constraints}
\item Section \hyperlink{doc:applications}{applications} shows how to apply some specific global constraints
\item Section \hyperlink{advanced:defineyourownconstraint}{user-defined constraint} explains how to create its own constraint.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% BINARY CONSTRAINT  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Binary constraints}\label{model:comparisonconstraints}\hypertarget{model:comparisonconstraints}{}
%The simplest constraints are comparisons which are defined over expressions of variables such as linear combinations. The following comparison constraints can be accessed through the \texttt{Model} API:
Constraints involving two integer variables
\begin{notedef}\tt
  \begin{itemize}
  \item \hyperlink{eq:eqconstraint}{eq}, \hyperlink{geq:geqconstraint}{geq}, \hyperlink{gt:gtconstraint}{gt}, \hyperlink{leq:leqconstraint}{leq}, \hyperlink{lt:ltconstraint}{lt}, \hyperlink{neq:neqconstraint}{neq}
  \item \hyperlink{abs:absconstraint}{abs}, \hyperlink{oppositesign:oppositesignconstraint}{oppositeSign}, \hyperlink{samesign:samesignconstraint}{sameSign}
  \end{itemize}
\end{notedef}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% TERNARY CONSTRAINT  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Ternary constraints}\label{model:ternaryconstraints}\hypertarget{model:ternaryconstraints}{}
Constraints involving three integer variables
\begin{notedef}\tt
  \begin{itemize}
  \item \hyperlink{distanceeq:distanceeqconstraint}{distanceEQ}, \hyperlink{distanceneq:distanceneqconstraint}{distanceNEQ}, \hyperlink{distancegt:distancegtconstraint}{distanceGT}, \hyperlink{distancelt:distanceltconstraint}{distanceLT}
  \item \hyperlink{intdiv:intdivconstraint}{intDiv}, \hyperlink{mod:modconstraint}{mod}, \hyperlink{times:timesconstraint}{times}
  \end{itemize}
\end{notedef}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% REAL CONSTRAINT  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Constraints involving real variables}\label{model:realconstraints}\hypertarget{model:realconstraints}{}
%The simplest constraints are comparisons which are defined over expressions of variables such as linear combinations. The following comparison constraints can be accessed through the \texttt{Model} API:
Constraints involving two real variables
\begin{notedef}\tt
  \begin{itemize}
  \item \hyperlink{eq:eqconstraint}{eq}, \hyperlink{geq:geqconstraint}{geq}, \hyperlink{leq:leqconstraint}{leq}
  \end{itemize}
\end{notedef}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% SET CONSTRAINT  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Constraints involving set variables}\label{model:setconstraints}\hypertarget{model:setconstraints}{}
%The simplest constraints are comparisons which are defined over expressions of variables such as linear combinations. The following comparison constraints can be accessed through the \texttt{Model} API:
Set constraints are illustrated on the \hyperlink{model:example2:ternarysteinerchoco}{ternary Steiner problem}. 
\begin{notedef}\tt
  \begin{itemize}
  \item \hyperlink{eqcard:eqcardconstraint}{eqCard}, \hyperlink{geqcard:geqcardconstraint}{geqCard}, \hyperlink{leqcard:leqcardconstraint}{leqCard}
  \item \hyperlink{member:memberconstraint}{member}, \hyperlink{notmember:notmemberconstraint}{notMember}
  \item \hyperlink{isincluded:isincludedconstraint}{isIncluded}, \hyperlink{isnotincluded:isnotincludedconstraint}{isNotIncluded}, \hyperlink{setdisjoint:setdisjointconstraint}{setDisjoint}
  \item \hyperlink{setinter:setinterconstraint}{setInter}, \hyperlink{setunion:setunionconstraint}{setUnion}
  \item \hyperlink{max:maxofaset}{max}, \hyperlink{min:minofaset}{min}
  \item \hyperlink{pack:packconstraint}{pack}
  \end{itemize}
\end{notedef}

%\hyperlink{max:maxconstraint}{max}, \hyperlink{min:minconstraint}{min},

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% CHANNELING CONSTRAINT  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Channeling constraints}\label{model:channelingconstraints}\hypertarget{model:channelingconstraints}{}
The use of a redundant model is a frequent technique to strengthen propagation or to get more freedom to design dedicated search heuristics. The following constraints allow to ensure integrity of different models:
\begin{notedef}\tt
  \begin{itemize}
  \item \hyperlink{inversechanneling:inversechannelingconstraint}{inverseChanneling}, \hyperlink{boolchanneling:boolchannelingconstraint}{boolChanneling}, \hyperlink{domainconstraint:domainconstraintconstraint}{domainConstraint}
  \end{itemize}
\end{notedef}
More complex channeling can be done using reified constraints (see Section \hyperlink{model:reifiedconstraints}{reification}) although they are less efficient. For example, to ensure that two variables are equal or not, one can reify the equality into a boolean variables :
\lstinputlisting{java/cchannelingreified.j2t}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% EXTENSIONS CONSTRAINT  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Constraints in extension and relations}\label{model:arbitraryconstraintsinextension}\hypertarget{model:arbitraryconstraintsinextension}{}
Choco supports the statement of constraints defining arbitrary relations over two or more variables.
Such a relation may be defined by three means:
\begin{itemize}
	\item \textbf{feasible table:} the list of allowed tuples of values (that belong to the relation),
	\item \textbf{infeasible table:} the list of forbidden tuples of values (that do not belong to the relation),
	\item \textbf{predicate:} a method to be called in order to check whether a tuple of values belongs or not to the relation.
\end{itemize}
On the one hand, constraints based on tables may be rather memory consuming in case of large domains, although one relation table may be shared by several constraints. On the other hand, predicate constraints require little memory as they do not cache truth values, but imply some run-time overhead for calling the feasibility test. Table constraints are thus well suited for constraints over small domains; while predicate constraints are well suited for situations with large domains. 

Different levels of consistency can be enforce on constraints in extension: 
\begin{itemize}
\item several arc-consistency (AC) algorithms for binary relations
\item two AC algorithms for n-ary relations dedicated either to positive or to negative tables (relation defined by the allowed or forbidden tuples)
\item a weaker forward-checking (FC) algorithm for n-ary relations.
\end{itemize}

The Choco API for creating constraints in extension are as follows:
\begin{notedef}\tt
  \begin{itemize}
  \item \hyperlink{feaspairac:feaspairacconstraint}{feasPairAC}, \hyperlink{infeaspairac:infeaspairacconstraint}{infeasPairAC}, \hyperlink{relationpairac:relationpairacconstraint}{relationPairAC}
  \item \hyperlink{feastupleac:feastupleacconstraint}{feasTupleAC}, \hyperlink{infeastupleac:infeastupleacconstraint}{infeasTupleAC}, \hyperlink{relationtupleac:relationtupleacconstraint}{relationTupleAC}
  \item \hyperlink{feastuplefc:feastuplefcconstraint}{feasTupleFC}, \hyperlink{infeastuplefc:infeastuplefcconstraint}{infeasTupleFC}, \hyperlink{relationtuplefc:relationtuplefcconstraint}{relationTupleFC}
  \end{itemize}
\end{notedef}

\subsubsection{Relations.}
A same relation might be shared among several constraints, in this case it is highly recommended to create it first and then use the \hyperlink{relationpairac:relationpairacconstraint}{relationPairAC}, \hyperlink{relationtupleac:relationtupleacconstraint}{relationTupleAC}, or \hyperlink{relationtuplefc:relationtuplefcconstraint}{relationTupleFC} API  on the same relation for each constraint.

For binary relations, the following Choco API is provided:
\mylst{makeBinRelation(int[] min, int[] max, List<int[]>pairs, boolean feas)}

It returns a \texttt{BinRelation} giving a list of compatible (\texttt{feas=true}) or incompatible (\texttt{feas=false}) pairs of values. This relation can be applied to any pair of variables $(x_1,x_2)$ whose domains are included in the \texttt{min/max} intervals, i.e. such that:
$$\mathtt{min}[i] \le x_i.\mathtt{getInf}() \le x_i.\mathtt{getSup}() \le  \mathtt{max}[i],\quad \forall i.$$
Bounds \texttt{min/max} are mandatory in order to allow to compute the opposite of the relation if needed.

For n-ary relations, the corresponding Choco API is:
\mylst{makeLargeRelation(int[] min, int[] max, List<int[]> tuples, boolean feas);}
It returns a \texttt{LargeRelation}. If \texttt{feas=true}, the returned relation matches also the \texttt{IterLargeRelation} interface which provides constant time iteration abilities over tuples (for compatibility with the GAC algorithm used over feasible tuples).
\lstinputlisting{java/mlargerelation.j2t}

Lastly, some specific relations can be defined without storing the tuples, as in the following example (\texttt{TuplesTest} extends \texttt{LargeRelation}):
\lstinputlisting{java/mnotallequal.j2t}
Then, a \emph{NotAllEqual} constraint can be stated within the problem by:
\lstinputlisting{java/mrelationtuplefc.j2t}
%Again, for compatibility with the GAC algorithm invoked by relationTupleAC, such a relation has to match the \texttt{IterLargeRelation} interface for feasible tuples.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% REIFIED CONSTRAINT  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Reified constraints}\label{model:reifiedconstraints}\hypertarget{model:reifiedconstraints}{}
Constraints involved in another constraint are usually called reified constraints. Typical examples of reified constraints are
 constraints combined with logical operators, such as $(x \neq y) \lor (z \le 9)$.

%\subsubsection{To reify a constraint into a boolean variable.}\label{model:toreifyaconstraintintoabooleanvariable}\hypertarget{model:toreifyaconstraintintoabooleanvariable}{}
Choco provides a generic constraint to reify any constraints on integer variables or set variables into a boolean variable expressing its truth value:
\begin{notedef}\tt
  \begin{itemize}
  \item \hyperlink{reifiedconstraint:reifiedconstraintconstraint}{reifiedConstraint}, \hyperlink{reifiedand:reifiedandconstraint}{reifiedAnd}, \hyperlink{reifiedleftimp:reifiedleftimpconstraint}{reifiedLeftImp}, \hyperlink{reifiednot:reifiednotconstraint}{reifiedNot}, \hyperlink{reifiedor:reifiedorconstraint}{reifiedOr}, \hyperlink{reifiedrightimp:reifiedrightimpconstraint}{reifiedRightImp}, \hyperlink{reifiedxnor:reifiedxnorconstraint}{reifiedXnor}, \hyperlink{reifiedxor:reifiedxorconstraint}{reifiedXor}
  \end{itemize}
\end{notedef}
This mechanism can be used for example to model MaxCSP problems where the number of satisfied constraints has to be maximized.
It is also intended to give the freedom to the user to build complex reified constraints. However, Choco provides a more simple and direct API to build complex expressions using boolean operators:
\begin{notedef}\tt
  \begin{itemize}
  \item \hyperlink{and:andconstraint}{and}, \hyperlink{or:orconstraint}{or}, \hyperlink{implies:impliesconstraint}{implies}, \hyperlink{ifonlyif:ifonlyifconstraint}{ifOnlyIf}, \hyperlink{ifthenelse:ifthenelseconstraint}{ifThenElse}, \hyperlink{not:notconstraint}{not}
  \end{itemize}
\end{notedef}
Such an expression is represented as a tree of operators. The leaves of this tree are made of variables, constants or even traditional constraints. Variables and constants can be combined as \texttt{ExpressionVariable} using \hyperlink{model:expressionvariables}{operators} (e.g, \texttt{mult(10,abs(w))}), or using simple constraints (e.g., \texttt{leq(z,9)}), or even using global constraints (e.g, \texttt{alldifferent(vars)}).
The language available on expressions is therefore slightly richer and matches the language used in the \href{http://cpai.ucc.ie/08/}{Constraint Solver Competition 2008} of the CPAI workshop.

For example, the following expression
$$((x = 10 * |y|) \lor (z \le 9))\quad \iff\quad \texttt{alldifferent}(a,b,c)$$
could be represented by :
\begin{lstlisting}
	Constraint exp = ifOnlyIf( or( eq(x, mult(10, abs(y))), leq(z, 9) ), 
                               alldifferent(new IntegerVariable[]{a,b,c}) );
\end{lstlisting}


\subsubsection{Handling complex expressions.}\label{model:handlingcomplexexpressions}\hypertarget{model:handlingcomplexexpressions}{}
Expressions offer a more powerful modeling language than the one available via standard constraints. However, they 
can not be handled as efficiently as the standard constraints that embed a dedicated propagation algorithm. We therefore
recommend you to carefully check that you can not model the expression using the intensional constraints of Choco before using
expressions.
Inside the solver, expressions can be represented in two different ways that can be decided at the modeling level, using the following {\tt Model} API:
\begin{lstlisting}
  setDefaultExpressionDecomposition(boolean decomp);
\end{lstlisting}
or the option \hyperlink{edecomp:edecompoptions}{\tt Options.E\_DECOMP}.
\begin{itemize}
\item The first way (\texttt{decomp=false}) is to handle them as \hyperlink{model:arbitraryconstraintsinextension}{constraints in extension}. The expression is then used to check a tuple in a dynamic way just like a n-ary relation that is defined without listing all the possible tuples. The expression is then propagated using the GAC3rm algorithm. This is very powerful as arc-consistency is obtained on the corresponding constraints.
\item The second way (\texttt{decomp=true}) is to decompose the expression automatically by introducing intermediate variables and eventually the generic \hyperlink{reifiedintconstraint:reifiedintconstraintconstraint}{\tt reifiedIntConstraint}. By doing so, the level of pruning decreases but expressions of larger arity involving large domains can be represented.
\end{itemize}

%\subsubsection{Tell the solver how to consider an expression.}
%The default representation of expressions can be enforced using the following API  on the model object: 
%Parameter \emph{decomp} tells the solver whether expressions shoud be considered as extensional constraints (\texttt{decomp=false}) or decomposed 
Once the default representation is chosen, one can also make exception for a particular expression using options on \texttt{addConstraint}. 
For example, the following code tells the solver to decompose e1 and not e2 :
\begin{lstlisting}
	model.setDefaultExpressionDecomposition(false);
	IntegerVariable x = makeIntVar("x", 1, 3, Options.V_BOUND);
	IntegerVariable y = makeIntVar("y", 1, 3, Options.V_BOUND);
	IntegerVariable z = makeIntVar("z", 1, 3, Options.V_BOUND);

	Constraint e1 = or(lt(x, y), lt(y, x));
	model.addConstraint(Options.E_DECOMP, e1);
	
	Constraint e2 = or(lt(y, z), lt(z, y));
	model.addConstraint(e2);
\end{lstlisting}

\subsubsection{When and how should I use expressions ?}\label{model:whenshouldiuseexpressions}\hypertarget{model:whenshouldiuseexpressions}{}
An expression (represented in extension) should be used in the case of a complex logical relationship that involves \textbf{few different variables}, each of \textbf{small domain}, and if \textbf{arc consistency} is desired on those variables.
In such a case, an expression can even be more powerful than a model using intermediate variables and intensional constraints.
Imagine the following ``crazy'' example :
\begin{lstlisting}
 or( and( eq( abs(sub(div(x,50),div(y,50))),1), eq( abs(sub(mod(x,50),mod(y,50))),2)),
     and( eq( abs(sub(div(x,50),div(y,50))),2), eq( abs(sub(mod(x,50),mod(y,50))),1)))
\end{lstlisting}
This expression has a small arity: it involves only two variables $x$ and $y$.
Let assume that their domains has no more than 300 values, then such an expression should typically not be decomposed. Indeed, arc consistency will create many holes in the domains and filter much more than if the relation was decomposed.

Conversely, an expression should be decomposed as soon as it involves a large number of variables, or at least one variable with a large domain.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% GLOBAL CONSTRAINT  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\subsection{Global constraints}\label{model:advancedconstraints}\hypertarget{model:advancedconstraints}{}
Choco includes several \href{http://www.emn.fr/x-info/sdemasse/gccat/}{global constraints}, such as:
\begin{notedef}\tt
\hyperlink{alldifferent:alldifferentconstraint}{allDifferent}, 
\hyperlink{globalcardinality:globalcardinalityconstraint}{globalCardinality}, 
\hyperlink{atmostnvalue:atmostnvalueconstraint}{atMostNValue},
\hyperlink{cumulative:cumulativeconstraint}{cumulative}, 
\hyperlink{lex:lexconstraint}{lex}, 
\hyperlink{regular:regularconstraint}{regular},
 \hyperlink{tree:treeconstraint}{tree},
\hyperlink{geost:geostconstraint}{geost}, etc.
\end{notedef}
Those constraints offer dedicated filtering algorithms which are able to make deductions where a decomposed model would not.
For instance, constraint \texttt{alldifferent}$(a,b,c,d)$ with $a,b\in[1,4]$ and $c,d\in[3,4]$ allows to deduce that $a$ and $b$ cannot be instantiated to $3$ or $4$; such rule cannot be inferred by simple binary constraints. 

The up-to-date list of global constraints available in Choco can be found within the Javadoc API.
Most of these global constraints are also described in Section \hyperlink{ch:constraints}{Constraints}.

\subsection{Scheduling constraints}\label{model:schedulingconstraints}\hypertarget{model:schedulingconstraints}{}
See also \hyperlink{schedulinganduseofthecumulative:schedulinganduseofthecumulativeconstraint}{scheduling application}.
\begin{notedef}\tt
\hyperlink{cumulative:cumulativeconstraint}{cumulative}, 
\hyperlink{disjunctive:disjunctiveconstraint}{disjunctive}, 
\hyperlink{geost:geostconstraint}{geost}, 
\hyperlink{pack:packconstraint}{pack}, 
\hyperlink{preceding:precedingconstraint}{preceding}, 
\hyperlink{precedencedisjoint:precedencedisjointconstraint}{precedenceDisjoint}, 
\hyperlink{precedenceimplied:precedenceimpliedconstraint}{precedenceImplied}, 
\hyperlink{precedencereified:precedencereifiedconstraint}{precedenceReified}.
\end{notedef}

\subsection{Sequencing constraints}\label{model:theregularconstraint}\hypertarget{model:theregularconstraint}{}
\begin{notedef}\tt
  \hyperlink{multicostregular:multicostregularconstraint}{multiCostRegular}, \hyperlink{regular:regularconstraint}{regular}, \hyperlink{stretchcyclic:stretchcyclicconstraint}{stretchCyclic}, \hyperlink{stretchpath:stretchpathconstraint}{stretchPath}, 
\end{notedef}

