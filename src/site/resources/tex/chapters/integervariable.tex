\section{Integer variables}\label{integervariable}\hypertarget{integervariable}{}
\texttt{IntegerVariable} is a variable whose associated domain is made of integer values. 

\subsubsection{constructors:}
      \noindent\begin{tabular}{p{.8\linewidth}p{.15\linewidth}}
        Choco method & return type \\
        \hline
        \mylst{makeIntVar(String name, int lowB, int uppB, String... options)} &\texttt{IntegerVariable}\\
		\mylst{makeIntVar(String name, List<Integer> values, String... options)} &\texttt{IntegerVariable}\\
		\mylst{makeIntVar(String name, int[] values, String... options)} &\texttt{IntegerVariable}\\
        \mylst{makeBooleanVar(String name, String... options)}  &\texttt{IntegerVariable}\\
        \mylst{makeIntVarArray(String name, int dim, int lowB, int uppB, String... options)} &\texttt{IntegerVariable[]}\\
        \mylst{makeIntVarArray(String name, int dim, int[] values, String... options)} &\texttt{IntegerVariable[]}\\
        \mylst{makeBooleanVarArray(String name, int dim, String... options)}  &\texttt{IntegerVariable[]}\\
        \mylst{makeIntVarArray(String name, int dim1, int dim2, int lowB, int uppB, String... options)}  &\texttt{IntegerVariable[][]}\\
        \mylst{makeIntVarArray(String name, int dim1, int dim2, int[] values, String... options)}  &\texttt{IntegerVariable[][]}\\
      \end{tabular}
% 	\begin{itemize}
% 		\item to create an \textbf{IntegerVariable} object:
% 		\begin{itemize}
% 			\item \mylst{makeIntVar(String name, int lowB, int uppB, String... options)}
% 			\item \mylst{makeIntVar(String name, List<Integer> values, String... options)}
% 			\item \mylst{makeIntVar(String name, int[] values, String... options)}
% 		\end{itemize}
% 		\item to create an \textbf{array of IntegerVariable} object:
% 		\begin{itemize}
% 			\item \mylst{makeIntVarArray(String name, int dim, int lowB, int uppB, String... options)}
% 			\item \mylst{makeIntVarArray(String name, int dim, int[] values, String... options)}
% 		\end{itemize}
% 		\item to create a \textbf{matrix of IntegerVariable} object:
% 		\begin{itemize}
% 			\item \mylst{makeIntVarArray(String name, int dim1, int dim2, int lowB, int uppB, String... options)}
% 			\item \mylst{makeIntVarArray(String name, int dim1, int dim2, int[] values, String... options)}
% 		\end{itemize}
% 		\item to create an \textbf{IntegerVariable} object with pre defined domain [0,1]:
% 		\begin{itemize}
% 			\item \mylst{makeBooleanVar(String name, String... options)}
% 		\end{itemize}
% 		\item to create an \textbf{array of IntegerVariable} object with pre defined domain [0,1]:
% 		\begin{itemize}
% 			\item \mylst{makeBooleanVarArray(String name, int dim, String... options)}
% 		\end{itemize}
% 	\end{itemize}
% 	\item \textbf{return type} : \texttt{IntegerVariable} \emph{or} \texttt{IntegerVariable[]} \emph{or} \texttt{IntegerVariable[][]}
\subsubsection{options:}
	\begin{itemize}
		\item \emph{no option} : equivalent to option \texttt{cp:enum}
		\item \texttt{cp:enum} : to force Solver to create enumerated domain for the variable. It is a domain in which holes can be created by the solver. It should be used when discrete and quite small domains are needed and when constraints performing Arc Consistency are added on the corresponding variables. Implemented by a \texttt{BitSet} object.
		\item \texttt{cp:bound} : to force Solver to create bounded domain for the variable. It is a domain where only bound propagation can be done (no holes). It is very well suited when constraints performing only Bound Consistency are added on the corresponding variables. It must be used when large domains are needed. Implemented by two integers.
		\item \texttt{cp:link} : to force Solver to create linked list domain for the variable. It is an enumerated domain where holes can be done and every values has a link to the previous value and to the next value. It is built by giving its name and its bounds: lower bound and upper bound. It must be used when the very small domains are needed, because although linked list domain consumes more memory than the \texttt{BitSet} implementation, it can provide good performance as iteration over the domain is made in constant time. Implemented by a \texttt{LinkedList} object.
		\item \texttt{cp:btree} : to force Solver to create binary tree domain for the variable. \emph{Under development}.
		\item \texttt{cp:blist} : to force Solver to create bipartite list domain for the variable. It is a domain where unavailable values are placed in the left part of the list, the other one on the right one.
		\item \texttt{cp:decision} : to force variable to be a decisional one
		\item \texttt{cp:no\_decision} : to force variable to be removed from the pool of decisional variables
		\item \texttt{cp:objective} : to define the variable to be the one to optimize
	\end{itemize}
\subsubsection{methods:}
      \begin{itemize}
      \item \mylst{removeVal(int val)}: remove value \emph{val} from the domain of the current variable
      \end{itemize}

A variable with $\{0,1\}$ domain is automatically considered as boolean domain.

\subsubsection{Example:}
\begin{lstlisting}
  IntegerVariable ivar1 = makeIntVar("ivar1", -10, 10);
  IntegerVariable ivar2 = makeIntVar("ivar2", 0, 10000, "cp:bound", "cp:decision");
  IntegerVariable bool = makeBooleanVar("bool");
\end{lstlisting} 
