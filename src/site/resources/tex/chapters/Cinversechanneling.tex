%\part{inversechanneling}
\label{inversechanneling}
\hypertarget{inversechanneling}{}

\section{inverseChanneling (constraint)}\label{inversechanneling:inversechannelingconstraint}\hypertarget{inversechanneling:inversechannelingconstraint}{}
\begin{notedef}
  \texttt{inverseChanneling}$(x,y)$ states a channeling between two arrays  $x$ and $y$ of integer variables with the same domain.It enforces that if the $i$-th element of $x$ is equal to $j$ then the $j$-th element of $y$ is equal to $i$ and conversely:
$$x_i = j\quad\iff\quad y_j = i$$
\end{notedef}
\begin{itemize}
	\item \textbf{API} : \mylst{inverseChanneling(IntegerVariable[] x, IntegerVariable[] y)}
	\item \textbf{return type} : \texttt{Constraint}
	\item \textbf{options} : \emph{no options}
	\item \textbf{favorite domain} : enumerated for x
	\item \textbf{references} :\\
      global constraint catalog: \href{http://www.emn.fr/x-info/sdemasse/gccat/Cinverse.html}{inverse}
\end{itemize}

\textbf{Example}:
\begin{lstlisting}
	int n = 8;
	Model m = new CPModel();
	IntegerVariable[] queens = new IntegerVariable[n];
	IntegerVariable[] queensdual = new IntegerVariable[n];
	for (int i = 0; i < n; i++) {
	    queens[i] = makeIntVar("Q" + i, 1, n);
	    queensdual[i] = makeIntVar("QD" + i, 1, n);
	}
	
	for (int i = 0; i < n; i++) {
	    for (int j = i + 1; j < n; j++) {
	       int k = j - i;
	       m.addConstraint(neq(queens[i], queens[j]));
	       m.addConstraint(neq(queens[i], plus(queens[j], k)));  // diagonal constraints
	       m.addConstraint(neq(queens[i], minus(queens[j], k))); // diagonal constraints
	    }
	}
	for (int i = 0; i < n; i++) {
	    for (int j = i + 1; j < n; j++) {
	        int k = j - i;
	        m.addConstraint(neq(queensdual[i], queensdual[j]));
	        m.addConstraint(neq(queensdual[i], plus(queensdual[j], k)));  // diagonal constraints
	        m.addConstraint(neq(queensdual[i], minus(queensdual[j], k))); // diagonal constraints
	    }
	}
	m.addConstraint(inverseChanneling(queens, queensdual));
	m.addVariable("cp:decision", queens);
	Solver s = new CPSolver();
	s.read(m);
	s.solveAll();
\end{lstlisting}
