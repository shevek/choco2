%\part{atmostnvalue}
\label{atmostnvalue}
\hypertarget{atmostnvalue}{}

\section{atMostNValue (constraint)}\label{atmostnvalue:atmostnvalueconstraint}\hypertarget{atmostnvalue:atmostnvalueconstraint}{}
\begin{notedef}
\texttt{atMostNValue}$(x,z)$ states that the number of different values occurring in the array of variables $x$ is at most \emph{z}:
$$z\ge|\{x_1,\ldots,x_n\}|$$  
\end{notedef}

\begin{itemize}
	\item \textbf{API} : \mylst{atMostNValue(IntegerVariable[] x, IntegerVariable z)}
	\item \textbf{return type} : \texttt{Constraint}
	\item \textbf{options} : \emph{n/a}
	\item \textbf{favorite domain} : \emph{n/a}
	\item \textbf{references} :
      \begin{itemize}
      \item  \cite{BessiereCPAIOR05} \emph{Filtering algorithms for the NValue constraint}
      \item global constraint catalog: \href{http://www.emn.fr/x-info/sdemasse/gccat/Catmost_nvalue.html}{\tt atmost\_nvalue}
      \end{itemize}
    \end{itemize}

\textbf{Example}:
\begin{lstlisting}
	Model m = new CPModel();
	CPSolver s = new CPSolver();
	
	IntegerVariable v1 = makeIntVar("v1", 1, 1);
	IntegerVariable v2 = makeIntVar("v2", 2, 2);
	IntegerVariable v3 = makeIntVar("v3", 3, 3);
	IntegerVariable v4 = makeIntVar("v4", 3, 4);
	IntegerVariable n = makeIntVar("n", 3, 3);
	
	Constraint c2 = atMostNValue(new IntegerVariable[]{v1, v2, v3, v4}, n);
	
	m.addConstraint(c1, c2);
	        
	s.read(m);
	s.solve();
\end{lstlisting}
