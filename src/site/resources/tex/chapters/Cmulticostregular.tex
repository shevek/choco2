%\part{multicostregular}
\label{multicostregular}
\hypertarget{multicostregular}{}

\section{multiCostRegular (constraint)}\label{multicostregular:multicostregularconstraint}\hypertarget{multicostregular:multicostregularconstraint}{}
\begin{notedef}
  \texttt{multiCostRegular}$(x,z,\mathcal{L}(\Pi),c)$ states that sequence $x$ is a word belonging to the regular language $\mathcal{L}(\Pi)$,
% recognized by a deterministic finite automaton (DFA) or a multicostregular expression $\Pi$:
$$(x_1,\ldots,x_n)\in\mathcal{L}(\Pi)$$
and that the bounded vector $z$ is equal to the costs of $x$ according to the assigment cost matrix $c$:
$$\sum_{i=1}^{n} c[r][i][x_i]=z[r],\quad \forall r\in\{0,\ldots,R\}$$
\end{notedef}
\texttt{multiCostRegular} is a conjunction of a \hyperlink{regular}{\texttt{regular}} constraint with $R+1$ cost functions.
It may be used in the context of personnel scheduling problems, handling complex work regulations by the mean of regular expressions, together with cardinality or financial constraints by the mean of cost functions.
The filtering algorithm associated with \texttt{multiCostRegular} is based on lagrangian relaxation and computations of shortest/longest pathes in a layered digraph~\cite{MenanaCPAIOR09}. It typically performs more filtering than the conjunction of \texttt{costRegular} and \texttt{globalCardinality} or than multiple \texttt{costRegular}.

The accepting language is specified by a deterministic finite automaton (DFA):
Automaton $\Pi$ is defined on a given \emph{alphabet} $\Sigma\subseteq\Z$ by a set $Q=\{0,\ldots,m\}$ of \emph{states}, a subset $A\subseteq Q$ of \emph{final} or \emph{accepting states} and a table $\Delta\subseteq Q\!\times\!\Sigma\!\times Q$ of \emph{transitions} between states. $\Pi$ is encoded as an object of class \texttt{Automaton}, whose API contains:
\begin{lstlisting}
  Automaton();
  int addState();
  void setStartingState(int state); 
  void setAcceptingState(int state); 
  void addTransition(int state1, int state2, int label);
  int getNbStates();
\end{lstlisting}
The cost functions are encoded as one matrix \texttt{int cost[nTime][nAct][auto.getNbStates()][nRes]} such that
\texttt{cost[i][j][s][r]} is the cost of assigning variable $x_i$ to activity $j$ at state $s$ on dimension $r+1$.

\begin{itemize}
	\item \textbf{API} : \mylst{multiCostRegular(IntegerVariable[] x, IntegerVariable[] z, Automaton P, int[][][][] c)}
	\item \textbf{return type} : \texttt{Constraint}
	\item \textbf{options} :
      \begin{itemize}
      \item \texttt{MultiCostRegular.DATA\_STRUCT} is  \texttt{MultiCostRegular.BITSET} or \texttt{MultiCostRegular.LIST}: a parameter stating which backtrable data structure to use for storing the outgoing arcs of the layered digraph. The observed behaviour is until $1000$ arcs the bipartite list is much more efficient, afterwards the memory efficiency of the bitset representation allow faster operations. 
      \item \texttt{MultiCostRegular.U0}, \texttt{MultiCostRegular.R0}, \texttt{MultiCostRegular.MAXNONIMPROVEITER}, and \texttt{MultiCostRegular.MAXBOUNDITER} are value parameters of the subgradient algorithm used for solving the lagrangean relaxation.
      \item \texttt{MultiCostRegular.D\_PREC} is a double parameter stating the precision of float computation. It is set by default to $10^{-5}$.
      \end{itemize}
	\item \textbf{favorite domain} : \emph{to complete}
	\item \textbf{references} :\\
       \cite{MenanaCPAIOR09}: \emph{Sequencing and Counting with the {\tt multicost-regular} Constraint}
\end{itemize}
%\begin{notedef}
%  For further informations, see the multicost-regular description.
%\end{notedef}

\textbf{Example}:
\lstinputlisting{java/cmulticosteregular_import.j2t}
\lstinputlisting{java/cmulticostregular.j2t}

