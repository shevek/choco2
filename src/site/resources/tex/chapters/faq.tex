%\part{faq}
\label{faq}
\hypertarget{faq}{}

\chapter{Frequently Asked Questions}\label{faq:frequentlyaskedquestions}\hypertarget{faq:frequentlyaskedquestions}{}

\section{Where can I find Choco ?}\label{faq:wherecanifindchoco}\hypertarget{faq:wherecanifindchoco}{}

See the \href{http://choco.emn.fr}{download page} if you want to download a version of Choco library.

\section{What is the required Java version to run Choco ?}\label{faq:whatistherequiredjavaversiontorunchoco}\hypertarget{faq:whatistherequiredjavaversiontorunchoco}{}

Choco requires \href{http://java.sun.com/javase/6/}{java6}.

\begin{note}
If you are working on Mac OS X 10.4 Tiger or if you do not have an Intel processor, you probably can not install java 6 on your OS. Please, take a look at \href{http://landonf.bikemonkey.org/static/soylatte/}{Soy latte}, which goals are ``support for Java 6 Development on Mac OS X 10.4 and 10.5, OpenJDK support for Java 7 on Mac OS X and On-time release of Java 7 for Mac OS X''.
\end{note}

\section{How to add the Choco library to my project?}\label{faq:howtoaddthechocolibrarytomyproject}\hypertarget{faq:howtoaddthechocolibrarytomyproject}{}

% commented out template(flowplay>?640x480 noautoPlay)

You just need to add Choco.X.x.x.jar to your classpath.

\textbf{IntelliJ}:
\begin{itemize}
	\item Go to ``File/Settings''
	\item Select ``Project Settings''
	\item Click on ``Librairies'' then on [+]
	\item Enter ``Choco'' as the library name, and OK
	\item Choose your project, and OK,
	\item Click on ``Attach Jar Directories'' and choose the directory where you put the Choco jar.
\end{itemize}

\todo{fix hyperlink{flowplay>videos:intellij.flv}{How to add choco to IntelliJ in video}}

\textbf{Eclipse}:
\begin{itemize}
	\item Go to ``Project/Properties'',
	\item Select ``Java Build Path'' on the left menu
	\item On the right, select ``Librairies''
	\item Click on ``Add Externals JARs...'' button
	\item Select the Choco jar file
\end{itemize}

\todo{fix hyperlink{flowplay>videos:eclipse.flv}{How to add choco to Eclipse in video}}

\begin{note}
If you work with \textbf{the source and not the jar of Choco}, do not forget to also add the automaton.jar and junit.jar, available in the lib/ directory
\end{note}

\section{Why can't I see the Choco API?}\label{faq:whycan'tiseethechocoapi}\hypertarget{faq:whycan'tiseethechocoapi}{}
To have the Choco API available, you must make the following import in your class file:

\begin{lstlisting}
import static choco.Choco.*;
\end{lstlisting}

\section{How to know the value of my variable in the Solver ?}\label{faq:howtoknowthevalueofmyvariableinthesolver}\hypertarget{faq:howtoknowthevalueofmyvariableinthesolver}{}
There are two different kinds of variables: those associated with the Model (like \texttt{IntegerVariable}, \texttt{SetVariable},...) and those associated with the Solver (like \texttt{IntDomainVar}, \texttt{SetVar},...). The second type is a Solver interpretation of the first one (which is only declarative).
After having defined your model with variables and constraints, it has to be read by the Solver. After that, a Solver object is created. You can access the Variable Model \emph{value} through the Solver using the following method of the Solver:
\mylst{solver.getVar(Variable v);}
where v is a Model variable (or an array of Model variables) and it returns a Solver variable.

\section{How do I use constant value inside constraint ?}\label{faq:howdoiuseconstantevalueinsideconstraint}\hypertarget{faq:howdoiuseconstantevalueinsideconstraint}{}
Some constraints doesn't provide API with java object (like \textbf{int}, \textbf{double} or \textbf{Integer}). 
You can define \emph{constant} variable (ie, variable with one unique value) liek this:
\begin{lstlisting}
	IntegerVariable one = constant(1);
	RealVariable one = constant(1.0);
\end{lstlisting}
And, you can use this \emph{variable} inside the constraint:
\begin{lstlisting}
	Model m = new CPModel();
	
	IntegerVariable x = makeIntVar("x", 0, 10);
	IntegerVariable two = constant(2);
	IntegerVariable maximum = makeIntVar("max", 0, 15);
	
	m.addConstraint(eq(maximum, max(x, two));
\end{lstlisting}

Do not forget that some contraints provide api with java object.

\section{How can I use Choco to solve CSP'08 benchmark ?}\label{faq:howcaniusechocotosolvecsp'08benchmark}\hypertarget{faq:howcaniusechocotosolvecsp'08benchmark}{}
You can easily load an XML file of the CSP'08 competition and solve it with Choco.
To load the file, we use the XMLParser available \href{http://www.cril.univ-artois.fr/\~{}lecoutre/research/tools/tools.html}{here}:
\begin{lstlisting}
	String fileName = "../../ProblemsData/CSPCompet/intension/nonregres/graph1.xml";
	File instance = new File(fileName);
	XmlModel xs = new XmlModel();  // a class to ease loading and solving CSP'08 xml file
	InstanceParser parser = xs.load(instance);  // loading of the CPS'08 xml file
\end{lstlisting}
Once the file has been loaded, a Model object is build from the InstanceParser object:
\begin{lstlisting}
CPModel model = xs.buildModel(parser); // Creation of the model
\end{lstlisting}
At this point, you can choose to solve this model with a pre-processing step.
The pre-processing step analyzes variables and constraints, makes some specific choices to improve the resolution.
Concerning variables, it analyzes domains and constraints and choose what seems to be the best kind of domain (for example, enumerated or bounded domain), or add one variable where large number of variables are equals, ...
Concerning constraints, it detects clique of differences or disjunctions and state the corresponding global constraints, breaks symetries, detects distance...
Then, it can also choose the search strategy.
To do this, use the following code:
\begin{lstlisting}
PreProcessCPSolver s = xs.solve(model); // Build a BlackBoxSolver and solve it.
\end{lstlisting}
Finally, you can print informations concerning the resolution:
\begin{lstlisting}
\lstinline|xs.postAnalyze(instance, parser, s);
\end{lstlisting}

You can easily solve benchmarks of CSP'08 competition, or with your own problem modelize in \href{http://www.cril.univ-artois.fr/cpai08/xcsp21.pdf}{CSP'08 xml format}.

\section{How do I use the build.xml file ?}\label{faq:howdoiusethebuild.xmlfile}\hypertarget{faq:howdoiusethebuild.xmlfile}{}

The choco project provides an ant script \texttt{build.xml} for the most usual tasks of the project.
In this section, we show how to run these tasks with a terminal. Ant is fully integrated in most of Java IDE but we will not talk about it.

First, we are going into the root directory of choco
\begin{lstlisting}
	nono@arrakis:~\$ cd /path/to/choco/
	nono@arrakis:~/workspace/Choco-2.0\$ ls
	bin  build.xml  checkstyle.xml  Choco2.0.0.iml  choco-ruleset.xml  dev  lib  pom.xml
\end{lstlisting}
Then, try a simple 
\begin{lstlisting}
	nono@arrakis:~/workspace/Choco-2.0\$ ant
	Buildfile: build.xml
	
	init:
	     [echo] Ant  version                  : Apache Ant version 1.7.0 compiled on August 29 2007
	     [echo] Java version                  : 1.6.0_06
	     [echo] build of project JChoco : June 30 2008
	
	help:
	     [echo] be careful, there could have a bug in eclipse with this help message.
	     [echo] In this case, type "ant -p popart/build.xml" in a terminal.     
	     [exec] Buildfile: build.xml
	     [exec] 
	     [exec] Main targets:
	     [exec] 
	     [exec]  clean            --> deletes everything that seems useless
	     [exec]  compile          --> compiles everything
	     [exec]  dist             --> makes the distribution package (jar, src.zip, doc.zip)
	     [exec]  doc              --> generates the javadoc
	     [exec]  exec-junit-test  --> executes all junit tests.
	     [exec]  exec-pmd         --> analyzes code with PMD and CPD
	     [exec]  help             --> print this help
	     [exec] Default target: help
	
	BUILD SUCCESSFUL
	Total time: 1 second
\end{lstlisting}

Most of these tasks do not have some special requirements. However, you could need specific settings to run \texttt{exec-junit-test} and \texttt{exec-pmd}.
You need to have \texttt{junit} and \texttt{ant-junit} jars in your classpath to run \texttt{exec\_junit-test}. But, it works for my first attempt without any changes.
You need to set \texttt{pmd} jar in your classpath and probably to update the property \texttt{pmd.xslt} to run \texttt{exec\_junit-test}.
Supposes that you have installed \texttt{pmd} in \texttt{/path/to/pmd}. You have to reset the location of the following property:
\begin{lstlisting}
<property name="pmd.xslt" location="/path/to/pmd/etc/xslt/wz-pmd-report.xslt" />
\end{lstlisting}
Finally you can run the task with :
\begin{lstlisting}
ant -lib /path/to/pmd/lib/pmd-4.1.jar exec-pmd
\end{lstlisting}
It seems that using PMD with your IDE is more effective. The integration offers many filtering options and allows to correct your code on the fly.

\emph{A \href{http://www.emn.fr/x-info/choco-solver/forum/viewtopic.phpf=5&t=4&start=0&st=0&sk=t&sd=a}{post} is opened for feedbacks, for new feature requests, and for any comments about the \texttt{build.xml} file}

\section{Why do I have a error when I add my constraint ?}\label{faq:whydoihaveaerrorwheniaddmyconstraint}\hypertarget{faq:whydoihaveaerrorwheniaddmyconstraint}{}
If you have a error message like this:\\
\centerline{\emph{Component class could not be found: my.package.and.my.Constraint.ConstraintManager}}\\
and if the ConstraintManager is an inner class of your constraint, you must define the name in the component name like this:
\begin{lstlisting}
my.package.and.my.Constraint\$ConstraintManager
\end{lstlisting}

For more details, see \hyperlink{advanced:defineyourownconstraint}{define\ your\ own\ constraint}.

\section{How do I upgrade my program to Choco2.0 ?}\label{faq:howdoiupgrademyprogramtochoco2.0}\hypertarget{faq:howdoiupgrademyprogramtochoco2.0}{}
Without being very precise (see the \hyperlink{ch:doc}{documentation} if you want more details), it is really easy to transpose a program implemented on an old version of Choco to Choco2.0.

\textbf{No Problem!!} The \texttt{Problem} class does not exist anymore. It has been replaced by two new classes: \texttt{CPModel} and \texttt{CPSolver} that implement the interfaces \texttt{Model} and \texttt{Solver.} The model allows you to declare your variables and constraints and the solver allows you to define some search strategies and solve your model. As different kinds of Model and Solver will be available, everything concerning Variables and Constraints is included in the new class \texttt{Choco}. 

Now, let us see in a few steps how to transpose your program. Consider that you created the following program:
\begin{lstlisting}
	// Creation of the problem
	Problem pb = new Problem();
	
	// Declaration of variables
	IntDomainVar v1 = pb.makeEnumIntVar("v1", 1, 10);
	IntDomainVar v2 = pb.makeEnumIntVar("v1", 1, 10);
	
	// Declaration of constraints
	Constraint c1 = pb.neq(v1,v2);
	pb.post(c1);
	// Declaration of a user constraint
	Constraint prime-number = MyConstraint(v1, v2);
	pb.post(prime-number);
	
	// Definition of a search strategy
	pb.getSolver().setVarSelector(new StaticVarOrder(v1, v2));
	pb.getSolver().setValIterator(new IncreasingDomain());
	
	// Resolution of the problem
	pb.solve();
	
	// Print the solution
	System.out.println("v1"+v1.getVal());
	System.out.println("v2"+v2.getVal());
\end{lstlisting}

\begin{itemize}
	\item \textbf{A Problem becomes a Model and a Solver}
\end{itemize}

\begin{lstlisting}
	// Creation of the problem
	Problem pb = new Problem();
\end{lstlisting}
becomes
\begin{lstlisting}
	// Creation of the Model
	Model m = new CPModel();
	//Creation of the Solver
	Solver s = new CPSolver();
\end{lstlisting}

\begin{itemize}
	\item \textbf{Variables are independent of a Problem or a Model}
\end{itemize}

\begin{lstlisting}
	// Declaration of variables
	IntDomainVar v1 = pb.makeEnumIntVar("v1", 1, 10);
	IntDomainVar v2 = pb.makeEnumIntVar("v1", 1, 10);
\end{lstlisting}
becomes
\begin{lstlisting}
	// add import:
	import static choco.Choco.*;
	//...
	// Declaration of variables
	IntegerVariable v1 = makeIntVar("v1", 1, 10);
	IntegerVariable v2 = makeIntVar("v1", 1, 10);
	m.addVariable(CPOptions.V_ENUM, v1, v2);
\end{lstlisting}

\begin{itemize}
	\item \textbf{Easy declaration of constraints}
\end{itemize}

\begin{lstlisting}
	// Declaration of constraints
	Constraint c1 = pb.neq(v1,v2);
	pb.post(c1);
\end{lstlisting}
becomes
\begin{lstlisting}
	// add import (same than Variables):
	import static choco.Choco.*;
	//...
	// Declaration of constraints
	Constraint c1 = neq(v1,v2);
	m.addConstraint(c1);
\end{lstlisting}

\begin{itemize}
	\item \textbf{A specific way to define user constraints}
\end{itemize}

\begin{lstlisting}
	// Declaration of a user constraint
	Constraint prime-number = myConstraint(v1, v2);
	pb.post(prime-number);
\end{lstlisting}
becomes
\begin{lstlisting}
	// Declaration of a user constraint
	m.addConstraint(new ComponentConstraint(MyManager.class, null, v1, v2));
\end{lstlisting}

\begin{itemize}
	\item \textbf{Do not forget to read the model}
\end{itemize}

It is a \emph{\textbf{new step}}, it has to be done! 
\begin{lstlisting}
	// Read the model
	s.read(m);
\end{lstlisting}

\begin{itemize}
	\item \textbf{Clear definition of the search strategy}
\end{itemize}

\begin{lstlisting}
	// Definition of a search strategy
	pb.getSolver().setVarSelector(new StaticVarOrder(v1, v2));
	pb.getSolver().setValIterator(new IncreasingDomain());
\end{lstlisting}
becomes
\begin{lstlisting}
	// Definition of a search strategy
	s.setVarIntSelector(new StaticVarOrder(s.getVar(v1, v2)));
	s.setValIntIterator(new IncreasingDomain());
\end{lstlisting}

\begin{itemize}
	\item \textbf{And the resolution}
\end{itemize}

\begin{lstlisting}
	// Resolution of the problem
	pb.solve();
\end{lstlisting}
becomes
\begin{lstlisting}
	// Resolution of the model
	s.solve();
\end{lstlisting}

\begin{itemize}
	\item \textbf{Printing the solution}
\end{itemize}

\begin{lstlisting}
	// Print the solution
	System.out.println("v1"+v1.getVal());
	System.out.println("v2"+v2.getVal());
\end{lstlisting}
becomes
\begin{lstlisting}
	// Print the solution
	System.out.println("v1"+s.getVar(v1).getVal());
	System.out.println("v2"+s.getVar(v2).getVal());
\end{lstlisting}

And it's done!
We obtain the following code:
\begin{lstlisting}
	import static choco.Choco.*;
	...
	// Creation of the Model
	Model m = new CPModel();
	//Creation of the Solver
	Solver s = new CPSolver();
	
	// Declaration of variables
	IntegerVariable v1 = makeIntVar("v1", 1, 10);
	IntegerVariable v2 = makeIntVar("v2", 1, 10);
	m.addVariable(CPOptions.V_ENUM,v1, v2);
	
	// Declaration of constraints
	Constraint c1 = neq(v1,v2);
	m.addConstraint(c1);
	// Declaration of a user constraint
	m.addConstraint(new ComponentConstraint(MyManager.class, null, v1, v2));
	
	// Read the model
	s.read(m);
	
	// Definition of a search strategy
	s.setVarIntSelector(new StaticVarOrder(s.getVar(v1, v2)));
	s.setValIntIterator(new IncreasingDomain());
	
	// Resolution of the model
	s.solve();
	
	// Print the solution
	System.out.println("v1"+s.getVar(v1).getVal());
	System.out.println("v2"+s.getVar(v2).getVal());
\end{lstlisting}

\section{Are bounds with positive and negative infinity supported within Choco?}\label{faq:areboundswithpositiveandnegativeinfinitysupportedwithinchoco}\hypertarget{faq:areboundswithpositiveandnegativeinfinitysupportedwithinchoco}{}

Integer or Double infinity bounds are not really appreciate by CHOCO :) 
Because, during propagation, a basic test is done on bounds and the following operation can be applied: 
\emph{upper bound +1}.
As \texttt{Integer.MAX\_VALUE+1} is equal to \texttt{Integer.MIN\_VALUE}, it can corrupt the propagation. 

If you really want to have a large domain, a division with 10 should be sufficient: 
\begin{lstlisting}
IntegerVariable v1 = makeIntVar("v1", Integer.MIN_VALUE/10, Integer.MIN_VALUE/10);
RealVariable a1 = makeRealVar("A1", Double.NEGATIVE_INFINITY/10, Double.POSITIVE_INFINITY/10);
\end{lstlisting}
