%\part{tree}
\label{tree}
\hypertarget{tree}{}

\section{tree (constraint)}\label{tree:treeconstraint}\hypertarget{tree:treeconstraint}{}

Let $G=(V,A)$ be a digraph on $V=\{1,\ldots,n\}$. $G$ can be modeled by a sequence of domain variables $x=(x_1,\dots,x_n)\in V^n$ -- the \emph{successors} variables -- whose respective domains are given by $D_i=\{j\in V\ |\ (i,j)\in A\}$. Conversely, when instantiated, $x$ defines a subgraph $G_x=(V,A_x)$ of $G$ with $A_x=\{(i,x_i)\ |\ i\in V\}\subseteq A$. Such a subgraph has one particularity: any connected component of $G_x$ contains either no loop -- and then it contains a cycle -- or exactly one loop $x_i=i$ and then it is a \emph{tree} of root $i$ (literally, it is an anti-arborescence as there exists a path from each node to $i$ and $i$ has a loop).

\begin{notedef}
  \texttt{tree}$(x,restrictions)$ is a vertex-disjoint graph partitioning constraint. It states that $G_x$ is a forest (its connected components are trees) that satisfies some conditions specified by $restrictions$.
\texttt{tree} deals with several kinds of graph restrictions on:
\begin{itemize}
	\item the number of trees
	\item the number of proper trees (a tree is proper if it contains more than 2 nodes)
    \item the weigth of the partition: the sum of the weights of the edges
	\item incomparability: some nodes in pairs have to belong to distinct trees
	\item precedence: some nodes in pairs have to belong to the same tree in a given order
	\item conditional precedence: some nodes in pairs have to respect a given order if they belong to the same tree
	\item the in-degree of the nodes
	\item the time windows on nodes (given travelling times on arcs)
\end{itemize}
\end{notedef}

Many applications require to partition a graph such that each component contains exactly one \emph{resource} node and several \emph{task} nodes. A typical example is a routing problem where vehicle routes are paths (a path is a special case of tree) starting from a depot and delivering goods to several clients. Another example is a local network where each computer has to be connected to one shared printer. Last, one can cite the problem of reconstructing plylogeny trees.
The constraint \texttt{tree} can handle these kinds of problems with many additional constraints on the structure of the partition.

\begin{itemize}
	\item \textbf{API} : \mylst{tree(TreeParametersObject param)}
	\item \textbf{return type} : \texttt{Constraint}
	\item \textbf{options} :\emph{n/a}
	\item \textbf{favorite domain} : \emph{to complete}
	\item \textbf{references} :
      \begin{itemize}
      \item \cite{beldiceanuCONSTRAINTS08}: \emph{Combining tree partitioning, precedence, and incomparability constraints}
      \item global constraint catalog: \href{http://www.emn.fr/x-info/sdemasse/gccat/Cproper_forest.html}{proper\_forest} (variant)
      \end{itemize}

\end{itemize}

The tree constraint API requires a particular Model object, named \textbf{\tt TreeParametersObject}.
It can be created with the following parameters:

\begin{tabular}{p{3cm}p{3cm}p{7cm}}
parameter &type &description\\
\hline
$n$ &\texttt{int} &number of nodes in the initial graph $G$\\
$nTree$ &\texttt{IntegerVariable} &number of trees in the resulting forest $G_x$\\
$nProper$ &\texttt{IntegerVariable} &number of proper trees in $G_x$\\
$objective$ &\texttt{IntegerVariable} &(bounded) total \todo{cost} of $G_x$\\
%$objective$ &\texttt{IntegerVariable} &(bounded) total weight of $G_x$\\
$graphs$ &\texttt{List<BitSet[]>} &
\begin{minipage}[t]{7cm}
graphs encoded as successor lists,\\
  \texttt{graphs[0]} the initial graph $G$,\\
  \texttt{graphs[1]} a precedence graph,\\
  \texttt{graphs[2]} a conditional precedence graph,\\
  \texttt{graphs[3]} an incomparability graph
\end{minipage}\\
$matrix$ &\texttt{List<int[][]>} &\texttt{matrix[0]} the indegree of each node, and \texttt{matrix[1]} the starting time from each node\\
$travel$ &\texttt{int[][]} &the travel time of each arc
\end{tabular}

\textbf{Example}:
\begin{lstlisting}
	Model m = new CPModel();
	int nbNodes = 7;

	//1- create the variables involved in the partitioning problem
	IntegerVariable ntree = makeIntVar("ntree",1,5);
	IntegerVariable nproper = makeIntVar("nproper",1,1);
	IntegerVariable objective = makeIntVar("objective",1,100);

	//2- create the different graphs modeling restrictions
	List<BitSet[]> graphs = new ArrayList<BitSet[]>();
	BitSet[] succ = new BitSet[nbNodes];
	BitSet[] prec = new BitSet[nbNodes];
	BitSet[] condPrecs = new BitSet[nbNodes];
	BitSet[] inc = new BitSet[nbNodes];
	for (int i = 0; i < nbNodes; i++) {
	    succ[i] = new BitSet(nbNodes);
	    prec[i] = new BitSet(nbNodes);
	    condPrecs[i] = new BitSet(nbNodes);
	    inc[i] = new BitSet(nbNodes);
	}

    // initial graph (encoded as successors variables)
	succ[0].set(0,true); succ[0].set(2,true); succ[0].set(4,true);
	succ[1].set(0,true); succ[1].set(1,true); succ[1].set(3,true);
	succ[2].set(0,true); succ[2].set(1,true); succ[2].set(3,true); succ[2].set(4,true);
	succ[3].set(2,true); succ[3].set(4,true); // successor of 3 is either 2 or 4
	succ[4].set(2,true); succ[4].set(3,true);
	succ[5].set(4,true); succ[5].set(5,true); succ[5].set(6,true);
	succ[6].set(3,true); succ[6].set(4,true); succ[6].set(5,true);

    // restriction on precedences
	prec[0].set(4,true); // 0 has to precede 4 
	prec[4].set(3,true); prec[4].set(2,true);
	prec[6].set(4,true);

    // restriction on conditional precedences
	condPrecs[5].set(1,true); // 5 has to precede 1 if they belong to the same tree 

    // restriction on incomparability:
	inc[0].set(6,true);	inc[6].set(0,true); // 0 and 6 have to belong to distinct trees

	graphs.add(succ);
	graphs.add(prec);
	graphs.add(condPrecs);
	graphs.add(inc);

	//3- create the different matrix modeling restrictions
	List<int[][]> matrix = new ArrayList<int[][]>();

    // restriction on bounds on the indegree of each node 
	int[][] degree = new int[nbNodes][2];
	for (int i = 0; i < nbNodes; i++) {
	    degree[i][0] = 0; degree[i][1] = 2;  // 0 <= indegree[i] <= 2
	}
	matrix.add(degree);

    // restriction on bounds on the starting time at each node 
	int[][] tw = new int[nbNodes][2];
	for (int i = 0; i < nbNodes; i++) {
	    tw[i][0] = 0; tw[i][1] = 100;   // 0 <= start[i] <= 100
	}
	tw[0][1] = 15;        				// 0 <= start[0] <= 15
	tw[2][0] = 35; tw[2][1] = 40;		// 35 <= start[2] <= 45
	tw[6][1] = 5;        				// 0 <= start[6] <= 5
	matrix.add(tw);

	//4- matrix for the travel time between each pair of nodes
	int[][] travel = new int[nbNodes][nbNodes];
	for (int i = 0; i < nbNodes; i++) {
	    for (int j = 0; j < nbNodes; j++) travel[i][j] = 100000;
	}
	travel[0][0] = 0; travel[0][2] = 10; travel[0][4] = 20;
	travel[1][0] = 20; travel[1][1] = 0; travel[1][3] = 20;
	travel[2][0] = 10; travel[2][1] = 10; travel[2][3] = 5; travel[2][4] = 5;
	travel[3][2] = 5; travel[3][4] = 2;
	travel[4][2] = 5; travel[4][3] = 2;
	travel[5][4] = 15; travel[5][5] = 0; travel[5][6] = 10;
	travel[6][3] = 5; travel[6][4] = 20; travel[6][5] = 10;

	//5- create the input structure and the tree constraint
	TreeParametersObject parameters = new TreeParametersObject(nbNodes, ntree, nproper, objective, graphs, matrix, travel);
	Constraint c = Choco.tree(parameters);

	m.addConstraint(c);
	Solver s = new CPSolver();
	s.read(m);
	
	//6- heuristic: choose successor variables as the only decision variables
	s.setVarIntSelector(new StaticVarOrder(s.getVar(parameters.getSuccVars())));
	CPSolver.setVerbosity(CPSolver.SOLUTION);
	s.solveAll();
\end{lstlisting} 
