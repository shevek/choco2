%\part{relationpairac}
\label{relationpairac}
\hypertarget{relationpairac}{}

\section{relationPairAC (constraint)}\label{relationpairac:relationpairacconstraint}\hypertarget{relationpairac:relationpairacconstraint}{}
\begin{notedef}
  \texttt{relationPairAC}$(x,y,rel)$ states an extensional binary constraint on $(x,y)$ defined by the binary relation $rel$:
$$(x,y)\in rel$$
\end{notedef}
Many constraints of the same kind often appear in a model. Relations can therefore often be shared among many constraints to spare memory.

The API is duplicated to allow definition of options.

\begin{itemize}
	\item \textbf{API} :
	\begin{itemize}
		\item \mylst{relationPairAC(IntegerVariable x, IntegerVariable y, BinRelation rel)}
		\item \mylst{relationPairAC(String options, IntegerVariable x, IntegerVariable y, BinRelation rel)}
	\end{itemize}
	\item \textbf{return type} : \texttt{Constraint}
	\item \textbf{options} :
	\begin{itemize}
		\item \emph{no option} : use AC3 (default arc consistency)
		\item \texttt{cp:ac3}: to get AC3 algorithm (searching from scratch for supports on all values)
		\item \texttt{cp:ac2001}: to get AC2001 algorithm (maintaining the current support of each value)
		\item \texttt{cp:ac32}: to get AC3rm algorithm (maintaining the current support of each value in a non backtrackable way)
		\item \texttt{cp:ac322}: to get AC3 with the used of \texttt{BitSet} to know if a support still exists
	\end{itemize}
	\item \textbf{favorite domain} : \emph{to complete}
\end{itemize}

\textbf{Example}:
\lstinputlisting{java/crelationpairac_import.j2t}
\lstinputlisting{java/ccoupletest.j2t}
\lstinputlisting{java/crelationpairac.j2t}
