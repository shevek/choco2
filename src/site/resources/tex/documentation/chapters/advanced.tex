%\part{advanced}
\label{advanced}
\hypertarget{advanced}{}


\chapter{Advanced uses of Choco}\label{advanced:advancedusesofchoco}\hypertarget{advanced:advancedusesofchoco}{}

\section{Environment}\label{advanced:environment}\hypertarget{advanced:environment}{}

Environment is a central object of the backtracking system. It defines the notion of \textit{world}. A world contains values of storable objects or operations that permit to \textit{backtrack} to its state. The environment \textit{pushes} and \textit{pops} worlds.

There are \textit{primitive} data types (\mylst{IstateBitSet, IStateBool, IStateDouble, IStateInt, IStateLong}) and \textit{objects} data types (\mylst{IStateBinarytree, IStateIntInterval, IStateIntProcedure, IStateIntVector, IStateObject, IStateVector}).

There are two different environments: \textit{EnvironmentTrailing} and \textit{EnvironmentCopying}.

\subsection{Copying}\label{advanced:copying}\hypertarget{advanced:copying}{}
In that environment, each data type is defined by a value (primitive or object) and a timestamp. Every time a world is pushed, each value is copied in an array (one array per data type), with finite indice. When a world is popped, every value is restored. 

\subsection{Trailing}\label{advanced:trailing}\hypertarget{advanced:trailing}{}
In that environment, data types are defined by its value. Every operation applied to a data type is pushed in a \textit{trailer}. When a world is pushed, the indice of the last operation is stored. When a world is popped, these operations are popped and \textit{unapplied} until reaching the last operation of the previous world.\\\textit{Default one in CPSolver}

\section{Define your own search strategy}\label{advanced:defineyourownsearchstrategy}\hypertarget{advanced:defineyourownsearchstrategy}{}
%A key ingredient of any constraint approach is a clever branching strategy. The construction of the search tree is done according to a series of Branching objects (that plays the role of achieving intermediate goals in logic programming). The user may specify the sequence of branching objects to be used to build the search tree. 
Section~\hyperlink{solver:searchstrategy}{Search strategy} presented the default branching strategies available in Choco and showed how to post them or to compose them as goals.
In this section, we will start with a very simple and common way to branch by choosing values for variables and specially how to define its own variable/value selection strategy. We will then focus on more complex branching such as dichotomic or n-ary choices. Finally we will show how to control the search space in more details with well known strategy such as LDS (Limited discrepancy search).

For integer variables, the variable and value selection strategy objects are based on the following interfaces:
\begin{itemize}
	\item \mylst{AbstractIntBranchingStrategy}: abstract class for the branching strategy,
	\item \mylst{VarSelector<V>} : Interface for the variable selection (\mylst{V extends Var}),
	\item \mylst{ValIterator<V>} : Interface to describes an iteration scheme on the domain of a variable,
	\item \mylst{ValSelector<V>} : Interface for a value selection.
\end{itemize}

Concrete examples of these interfaces are respectively,  \hyperlink{assignvar:assignvarbranchstrat}{AssignVar}, \hyperlink{mindomain:mindomainvarselector}{MinDomain}, \hyperlink{increasingdomain:increasingdomainvaliterator}{IncreasingDomain}, \hyperlink{maxval:maxvalvalselector}{MaxVal}.


\subsection{How does a search loop work ?}\label{advanced:howdoesasearchloopwork}\hypertarget{advanced:howdoesasearchloopwork}{}
To understand search strategy, it is good to know how it is invoked. This is done in the search loop. It goes down and up in the branches in order to cover the tree search.
Here is the organigram of the search loop. 

%\insertGraphique{0.8\linewidth}{media/searchloop.pdf}{Organigram of the search loop}

\begin{figure}[!htp]
	\centerline{\Graph{media/searchloop.pdf}{width=0.8\linewidth}}
	\caption[]{Organigram of the search loop}\label{fig:media/searchloop.pdf}
\end{figure}

Basically, the search loop is divided in 4 steps: \mylst{INITIAL PROPAGATION} (highlighted in red), \mylst{OPEN NODE} (highlighted in green), \mylst{DOWN BRANCH} (highlighted in violet) and \mylst{UP BRANCH} (highlighted in orange). 

\subsection{How to define your own Branching object}\label{advanced:beyondvariable/valueselection,howtodefineyourownbranchingobject}\hypertarget{advanced:beyondvariable/valueselection,howtodefineyourownbranchingobject}{}

When you need a specific branching strategy that can't be expressed with the ones already existing, you can define your own concrete class of:

\noindent{\begin{tabular}{ll}
\hline
  Default class to implement &  definition \\
  \hline
  \mylst{AbstractBinIntBranchingStrategy} &  abstract class defining a binary tree search \\
  \mylst{AbstractLargeIntSConstraint} &  abstract class defining a n-ary tree search. \\
  \hline\\
\end{tabular}}


\insertGraphique{\linewidth}{media/branching.pdf}{Branching strategy: interfaces and abstract classes.}

We give here two examples of implementations of these classes, first for a binary branching, then for a n-ary branching. 
\begin{lstlisting}   
/**
 * A class for branching schemes that consider two branches: 
 * - one assigning a value to an IntVar (X == v) 
 * - and the other forbidding this assignment (X != v)
 */
public class AssignOrForbid extends AbstractBinIntBranchingStrategy {

    protected VarSelector<IntDomainVar> varSelector;

    protected ValSelector<IntDomainVar> valSelector;

    public AssignOrForbid(VarSelector<IntDomainVar> varSelector,
                          ValSelector<IntDomainVar> valSelector) {
        super();
        this.valSelector = valSelector;
        this.varSelector = varSelector;
    }

    /**
     * Select the variable to constrained
     *
     * @return the branching object
     */
    public Object selectBranchingObject() throws ContradictionException {
        return varSelector.selectVar();
    }

    /**
     * Select the value to assign, and set it in the decision object in parameter
     * @param decision the next decision to apply
     */
    @Override
    public void setFirstBranch(final IntBranchingDecision decision) {
        decision.setBranchingValue(valSelector.getBestVal(decision.getBranchingIntVar()));
    }


    /**
     * Create and return the message to print, in case of strong verbosity
     * @param decision current decision
     * @return pretty print of the current decision
     */
    @Override
    public String getDecisionLogMessage(final IntBranchingDecision decision) {
        return decision.getBranchingObject() +  (decision.getBranchIndex() == 0 ? "==" : "=/=") + decision.getBranchingValue();
    }


    /**
     * Execution action based on the couple: {decision, branching index}.
     * As <code>this</code> build a binary branching, there are only 2 branching indices:
     * 0 -- assignment, the variable is instantiated to the value
     * 1 -- forbidance, the value is removed from the domain of the variable
     *
     * @throws ContradictionException if the decision leads to an incoherence
     */
    @Override
    public void goDownBranch(final IntBranchingDecision decision) throws ContradictionException {
        if (decision.getBranchIndex() == 0) {
            decision.setIntVal();
        } else {
            decision.remIntVal();
        }
    }
}
\end{lstlisting}

\begin{lstlisting}   
/**
 * A class for branching schemes that consider n branches: 
 * -  assigning a value v_i to an variable (X == v_i)
 */
public class Assign extends AbstractLargeIntBranchingStrategy {

    protected final VarSelector<IntDomainVar> varSelector;

    protected ValIterator<IntDomainVar> valIterator;

    public Assign(VarSelector<IntDomainVar> varSelector, ValIterator<IntDomainVar> valIterator) {
        this.varSelector = varSelector;
        this.valIterator = valIterator;
    }

    /**
     * Select the variable to constrained
     *
     * @return the branching object
     */
    public Object selectBranchingObject() throws ContradictionException {
        return varSelector.selectVar();
    }

    /**
     * Select the first value to assign, and set it in the decision object in parameter
     *
     * @param decision the first decision to apply
     */
    public void setFirstBranch(final IntBranchingDecision decision) {
        decision.setBranchingValue(valIterator.getFirstVal(decision.getBranchingIntVar()));
    }

    /**
     * Select the next value to assign, and set it in the decision object in parameter
     *
     * @param decision the next decision to apply
     */
    public void setNextBranch(final IntBranchingDecision decision) {
        decision.setBranchingValue(valIterator.getNextVal(decision.getBranchingIntVar(), decision.getBranchingValue()));
    }

    /**
     * Check wether there is still a value to assign
     *
     * @param decision the last decision applied
     * @return <code>false</code> if there is still a branching to do
     */
    public boolean finishedBranching(final IntBranchingDecision decision) {
        return !valIterator.hasNextVal(decision.getBranchingIntVar(), decision.getBranchingValue());
    }

    /**
     * Apply the computed decision building the i^th branch.
     * --> assignment: the variable is instantiated to the value
     * 
     * 
     * @param decision the decision to apply.
     * @throws ContradictionException if the decision leads to an incoherence
     */
    @Override
    public void goDownBranch(final IntBranchingDecision decision) throws ContradictionException {
        decision.setIntVal();
    }

    /**
     * Reconsider the computed decision, destroying the i^th branch
     * --> forbiddance: the value is removed from the domain of the variable
     * 
     * @param decision the decision that has been set at the father choice point
     * @throws ContradictionException if the non-decision leads to an incoherence
     */
    @Override
    public void goUpBranch(final IntBranchingDecision decision) throws ContradictionException {
        decision.remIntVal();
    }

    /**
     * Create and return the message to print, in case of strong verbosity
     * @param decision current decision
     * @return pretty print of the current decision
     */
    @Override
    public String getDecisionLogMessage(IntBranchingDecision decision) {
        return decision.getBranchingObject() + "==" + decision.getBranchingValue();
    }
}
\end{lstlisting}

\subsection{Define your own variable selection}\label{advanced:defineyourownvariableselection}\hypertarget{advanced:defineyourownvariableselection}{}

\insertGraphique{.5\linewidth}{media/varselector-s.pdf}{Variable selector: interface}

You may extend this small library of branching schemes and heuristics by defining your own concrete classes of \mylst{AbstractIntVarSelector}. We give here an example of an \mylst{VarSelector<IntDomainVar>} with the implementation of a static variable ordering :
\begin{lstlisting}
/**
 * A variable selector selecting the first non instantiated variable according to a given static order
 */
public class StaticVarOrder extends AbstractIntVarSelector {

    private final IStateInt last;

    public StaticVarOrder(Solver solver) {
        super(solver);
        this.last = solver.getEnvironment().makeInt(0);
    }

    public StaticVarOrder(Solver solver, IntDomainVar[] vars) {
        super(solver, vars);
        this.last = solver.getEnvironment().makeInt(0);
    }

    /**
     * Select the next uninstantiated variable, according to the define policy: input order
     * @return the selected variable if exists, <code>null</code> otherwise
     */
    public IntDomainVar selectVar() {
        for (int i = last.get(); i < vars.length; i++) {
            if (!vars[i].isInstantiated()) {
                last.set(i);
                return vars[i];

            }
        }
        return null;
    }
}
\end{lstlisting}

Notice on this example that you only need to implement method \mylst{selectVar()} which belongs to the contract of \mylst{VarSelector}. This method should return a non instantiated variable or \mylst{null}. Once the branching is finished, the next branching (if one exists) is taken by the search algorithm to continue the search, otherwise, the search stops as all variable are instantiated. To avoid the loop over the variables of the branching, a backtrackable integer (\mylst{IStateInt}) could be used to remember the last instantiated variable and to directly select the next one in the table. Notice that backtrackable structures could be used in any of the code presented in this chapter to speedup the computation of dynamic choices.

\insertGraphique{.8\linewidth}{media/varselector-a.pdf}{Variable selector: interface and abstract classes}

If you need an integer variable selector that can be used as a parameter of \hyperlink{lexintvarselector:lexintvarselectorvarselector}{LexIntVarSelector}, it should extend \mylst{IntHeuristicIntVarSelector} or \mylst{DoubleHeuristicIntVarSelector}. These two abstract classes only require to implement one method : \mylst{getHeuristic(IntDomainVar v)} which computes and returns a criterion (\mylst{int} or \mylst{double}). The criteria are used in a master class to select the smallest crtierion's variable 

We give here an other example of an \mylst{VarSelector<IntDomainVar>}, this one extends \mylst{IntHeuristicIntVarSelector} and choose the variable with the smallest domain :
\begin{lstlisting}
public class MinDomain extends IntHeuristicIntVarSelector {

	public MinDomain(Solver solver) {
		super(solver);
	}

	public MinDomain(Solver solver, IntDomainVar[] vs) {
		super(solver, vs);
	}

    /**
     * Compute the criterion, according to the define policy: smallest domain size
     * @return the selected variable if exists, <code>null</code> otherwise
     */
	@Override
	public int getHeuristic(IntDomainVar v) {
		return v.getDomainSize();
	}

}
\end{lstlisting}


You can add your variable selector as a part of a search strategy, using \mylst{solver.addGoal()}.

\subsection{Define your own value selection}\label{advanced:defineyourownvalueselection}\hypertarget{advanced:defineyourownvalueselection}{}
You may also define your own concrete classes of \mylst{ValIterator} or \mylst{ValSelector}. 

\subsubsection{Value selector}\label{advanced:valueselector}\hypertarget{advanced:valueselector}{}

\insertGraphique{.3\linewidth}{media/valselector.pdf}{Value selector: interface}

We give here an example of an \mylst{IntValSelector} with the implementation of a minimum value selecting:
\begin{lstlisting}
public class MinVal implements ValSelector<IntDomainVar> {
  /**
   * selecting the lowest value in the domain
   *
   * @param x the variable under consideration
   * @return what seems the most interesting value for branching
   */
  public int getBestVal(IntDomainVar x) {
    return x.getInf();
  }
}
\end{lstlisting}
Only \mylst{getBestVal()} method must be implemented, returning the best value \emph{in the domain} according to the heuristic.

You can add your value selector as a part of a search strategy, using \mylst{solver.addGoal()}.

\begin{note}
Using a value selector with bounded domain variable is strongly inadvised, except if it pick up bounds value. If the value selector pick up a value that is not a bound, when it goes up in the tree search, that value could be not removed and picked twice (or more)!
\end{note} 

\subsubsection{Values iterator}\label{advanced:valuesiterator}\hypertarget{advanced:valuesiterator}{}

\insertGraphique{.3\linewidth}{media/valiterator.pdf}{Value iterator: interface}

We give here an example of an \mylst{ValIterator} with the implementation of an increasing domain iterator:
\begin{lstlisting}
public class IncreasingDomain implements ValIterator<IntDomainVar> {

  /**
   * testing whether more branches can be considered after branch i, on the alternative associated to variable x
   *
   * @param x the variable under scrutiny
   * @param i the index of the last branch explored
   * @return true if more branches can be expanded after branch i
   */
  public boolean hasNextVal(IntDomainVar x, int i) {
    return (i < x.getSup());
  }

  /**
   * Accessing the index of the first branch for variable x
   *
   * @param x the variable under scrutiny
   * @return the index of the first branch (such as the first value to be assigned to the variable)
   */
  public int getFirstVal(IntDomainVar x) {
    return x.getInf();
  }

  /**
   * generates the index of the next branch after branch i, on the alternative associated to variable x
   *
   * @param x the variable under scrutiny
   * @param i the index of the last branch explored
   * @return the index of the next branch to be expanded after branch i
   */
  public int getNextVal(IntDomainVar x, int i) {
    return x.getNextDomainValue(i);
  }
}
\end{lstlisting}
%Works as an basic \mylst{Iterator} object, implementing the three main methods \mylst{hasNextVal()}, \mylst{getFirstVal()} and \mylst{getNextVal()}.

You can add your value iterator as a part of a search strategy, using \mylst{solver.addGoal()}.

\todo{under development} See \href{http://choco-solver.net/index.phptitle=userguide:beyondvariable.2fvalueselection.2chowtodefineyourownbranchingobject}{old version}

\section{Define your own limit search space}\label{advanced:defineyourownlimitsearchspace}\hypertarget{advanced:defineyourownlimitsearchspace}{}

To define your own limits/statistics (notice that a limit object can be used only to get statistics about the search), you can create a limit object by extending the \mylst{AbstractGlobalSearchLimit} class or implementing directly the interface \mylst{IGlobalSearchLimit}. Limits are managed at each node of the tree search and are updated each time a node is open or closed. Notice that limits are therefore time consuming. Implementing its own limit need only to specify to the following interface :

\begin{lstlisting}
	/**
	 * The interface of objects limiting the global search exploration
	 */
	public interface GlobalSearchLimit {

	  /**
	   * resets the limit (the counter run from now on)
	   * @param first true for the very first initialization, false for subsequent ones
	   */
	  public void reset(boolean first);
	
	  /**
	   * notify the limit object whenever a new node is created in the search tree
	   * @param solver the controller of the search exploration, managing the limit
	   * @return true if the limit accepts the creation of the new node, false otherwise
	   */
	  public boolean newNode(AbstractGlobalSearchSolver solver);
	
	  /**
	   * notify the limit object whenever the search closes a node in the search tree
	   * @param solver the controller of the search exploration, managing the limit
	   * @return true if the limit accepts the death of the new node, false otherwise
	   */
	  public boolean endNode(AbstractGlobalSearchSolver solver);
	}
\end{lstlisting}

Look at the following example to see a concrete implementation of the previous interface. We define here a limit on the depth of the search (which is not found by default in choco). The \mylst{getWorldIndex()} is used to get the current world, i.e the current depth of the search or the number of choices which have been done from baseWorld. 

\begin{lstlisting}
	public class DepthLimit extends AbstractGlobalSearchLimit {
	
	  public DepthLimit(AbstractGlobalSearchSolver theSolver, int theLimit) {
	    super(theSolver,theLimit);
	    unit = "deep";
	  }
	
	  public boolean newNode(AbstractGlobalSearchSolver solver) {
	    nb = Math.max(nb, this.getProblem().getWorldIndex() ‚Äì
	    this.getProblem().getSolver().getSearchSolver().baseWorld);
	    return (nb < nbMax);
	  }
	
	  public boolean endNode(AbstractGlobalSearchSolver solver) {
	    return true;
	  }
	
	  public void reset(boolean first) {
	   if (first) {
	    nbTot = 0;
	   } else {
	    nbTot = Math.max(nbTot, nb);
	   }
	   nb = 0;
	  }
\end{lstlisting}

Once you have implemented your own limit, you need to tell the search solver to take it into account. Instead of using a call to the \mylst{solve()} method, you have to create the search solver by yourself and add the limit to its limits list such as in the following code :
\begin{lstlisting}
	Solver s = new CPSolver();
	s.read(model);
	s.setFirstSolution(true);
	s.generateSearchStrategy();
	s.getSearchStrategy().limits.add(new DepthLimit(s.getSearchStrategy(),10));
	s.launch();
\end{lstlisting}

%\subsubsection{Search loop with recomputation}\label{advanced:searchloopwithrecomputation}\hypertarget{advanced:searchloopwithrecomputation}{}

\section{Define your own constraint}\label{advanced:defineyourownconstraint}\hypertarget{advanced:defineyourownconstraint}{}

This section describes how to add you own constraint, with specific propagation algorithms. Note that this section is only useful in case you want to express a constraint for which the basic propagation algorithms (using tables of tuples, or boolean predicates) are not efficient enough to propagate the constraint.

The general process consists in defining a new constraint class and implementing the various propagation methods. We recommend the user to follow the examples of existing constraint classes (for instance, such as \mylst{GreaterOrEqualXYC} for a binary inequality) 

\subsection{The constraint hierarchy}\label{advanced:theconstrainthierarchy}\hypertarget{advanced:theconstrainthierarchy}{}

Each new constraint must be represented by an object implementing the \mylst{SConstraint} interface (\mylst{S} for solver constraint). To help the user defining new constraint classes, several abstract classes defining \texttt{SConstraint} have been implemented. These abstract classes provide the user with a management of the constraint network and the propagation engineering. They should be used as much as possible.

For constraints on integer variables, the easiest way to implement your own constraint is to inherit from one of the following classes, depending of the number of solver integer variables (\texttt{IntDomainVar}) involved:

\centerline{\begin{tabular}{ll}
      \hline
  Default class to implement &  number of solver integer variables \\
  \hline
  \mylst{AbstractUnIntSConstraint} &  \textbf{one} variable \\
  \mylst{AbstractBinIntSConstraint} &  \textbf{two} variables \\
  \mylst{AbstractTernIntSConstraint} &  \textbf{three} variables \\
  \mylst{AbstractLargeIntSConstraint} &  any number of variables. \\
  \hline\\
\end{tabular}}

\noindent Constraints over integers must implement the following methods (grouped in the \texttt{IntSConstraint} interface):

\noindent\begin{tabular}{lp{.6\linewidth}}
  \hline
  Method to implement &  description \\
  \hline
  \mylst{pretty()} &Returns a pretty print of the constraint \\
  \mylst{propagate()} &The main propagation method (propagation from scratch). Propagating the constraint until local consistency is reached. \\
  \mylst{awake()} &Propagating the constraint for the very first time until local consistency is reached. The awake is meant to initialize the data structures contrary to the propagate. Specially, it is important to avoid initializing the data structures in the constructor. \\
  \mylst{awakeOnInst(int x)} &Default propagation on instantiation: full constraint re-propagation. \\
  \mylst{awakeOnBounds(int x)} &Default propagation on improved bounds: propagation on domain revision. \\
  \mylst{awakeOnRemovals(int x, IntIterator v)} &Default propagation on mutliple values removal: propagation on domain revision. The iterator allow to iterate over the values that have been removed. \\
&\\
\hline
\multicolumn{2}{l}{Methods \texttt{awakeOnBounds} and \texttt{awakeOnRemovals} can be replaced by more fine grained methods:}\\
\hline
%Alternative Method &  description \\
%  \hline
  \mylst{awakeOnInf(int x)} &Default propagation on improved lower bound: propagation on domain revision. \\
  \mylst{awakeOnSup(int x)} &Default propagation on improved upper bound: propagation on domain revision. \\
  \mylst{awakeOnRem(int x, int v)} &Default propagation on one value removal: propagation on domain revision.  \\
&\\
  \hline
\multicolumn{2}{l}{To use the constraint in expressions or reification, the following minimum API is mandatory:}\\
  \hline
  \mylst{isSatisfied(int[] x)} &Tests if the constraint is satisfied when the variables are instantiated. \\
	\mylst{isEntailed()} &Checks if the constraint must be checked or must fail. It returns true if the constraint is known to be satisfied whatever happend on the variable from now on, false if it is violated. \\
	\mylst{opposite()} &It returns an AbstractSConstraint that is the opposite of the current constraint. \\
    \hline\\
	\end{tabular}

In the same way, a \textbf{set constraint} can inherit from \texttt{AbstractUnSetSConstraint}, \texttt{AbstractBinSetSConstraint}, \texttt{AbstractTernSetSConstraint} or \texttt{AbstractLargeSetSConstraint}.

A \textbf{real constraint} can inherit from \texttt{AbstractUnRealSConstraint}, \texttt{AbstractBinRealSConstraint} or \texttt{AbstractLargeRealSConstraint}.

A mixed constraint between \textbf{set and integer variables} can inherit from \texttt{AbstractBinSetIntSConstraint} or \texttt{AbstractLargeSetIntSConstraint}.

\begin{note}
A simple way to implement its own constraint is to:
\begin{itemize}
	\item create an empty constraint with only \texttt{propagate()} method implemented and every \texttt{awakeOnXxx()} ones set to \texttt{this.constAwake(false);}
	\item when the propagation filter is sure, separate it into the \texttt{awakeOnXxx()} methods in order to have finer granularity
	\item finally, if necessary, use backtrackables objects to improve the efficient of your constraint
\end{itemize}

\end{note}

\subsubsection{How do I add my constraint to the Model ?}\label{advanced:howdoiaddmyconstrainttothemodel}\hypertarget{advanced:howdoiaddmyconstrainttothemodel}{}

Adding your constraint to the model requires you to definite a specific constraint manager (that can be a inner class of your Constraint).
This manager need to implement:
\begin{lstlisting}
makeConstraint(Solver s, Variable[] vars, Object params, HashSet<String> options)
\end{lstlisting}
This method allows the Solver to create an instance of your constraint, with your parameters and Solver objects.

\begin{note}
If you create your constraint manager as an inner class, you must declare this class as \textbf{public and static}.
If you don't, the solver can't instantiate your manager.
\end{note}

Once this manager has been implemented, you simply add your constraint to the model using the \texttt{addConstraint()} API with a \texttt{ComponentConstraint} object:
\begin{lstlisting}
  model.addConstraint( new ComponentConstraint(MyConstraintManager.class, params, vars) );
  // OR
  model.addConstraint( new ComponentConstraint("package.of.MyConstraint", params, vars) );
\end{lstlisting}
Where \emph{params} is whatever you want (\texttt{Object[], int, String},...) and \emph{vars} is an array of Model Variables (or more specific) objects.

\subsection{Example: implement and add the \texttt{IsOdd} constraint}
One creates the constraint by implementing the \texttt{AbstractUnIntSConstraint} (one integer variable) class:
\lstinputlisting{java/isodd.j2t}

To add the constraint to the model, one creates the following class (or inner class):
\lstinputlisting{java/isoddmanager.j2t}
It calls the constructor of the constraint, with every \emph{vars}, \emph{params} and \emph{options} needed.

Then, the constraint can be added to a model as follows:
\begin{lstlisting}
	// Creation of the model
	Model m = new CPModel();
	
	// Declaration of the variable
	IntegerVariable aVar = Choco.makeIntVar("a_variable", 0, 10);
	
	// Adding the constraint to the model, 1st solution:
	m.addConstraint(new ComponentConstraint(IsOddManager.class, null, new IntegerVariable[]{aVar}));
	// OR 2nd solution:
	m.addConstraint(new ComponentConstraint("myPackage.Constraint.IsOddManager", null, new IntegerVariable[]{aVar}));
	
	Solver s = new CPSolver();
	s.read(m);
	s.solve();
\end{lstlisting}
And that's it!!

\subsection{Example of an empty constraint}\label{advanced:anexempleofemptyconstraint}\hypertarget{advanced:anexempleofemptyconstraint}{}

%See the complete code: \href{media/zip/constraintpattern.zip}{ConstraintPattern.zip}

\begin{lstlisting}
  public class ConstraintPattern extends AbstractLargeIntSConstraint {
      
      public ConstraintPattern(IntDomainVar[] vars) {
          super(vars);
      }
	
      /**
      * pretty print. The String is not constant and may depend on the context.
      * @return a readable string representation of the object
      */
      public String pretty() {
          return null;
      }
	
      /**
      * check whether the tuple satisfies the constraint
      * @param tuple values
      * @return true if satisfied
      */
      public boolean isSatisfied(int[] tuple) {
          return false;
      }

      /**
      * propagate until local consistency is reached
      */
      public void propagate() throws ContradictionException {
          // elementary method to implement
      }
	    
      /**
      * propagate for the very first time until local consistency is reached.
      */
      public void awake() throws ContradictionException {
          constAwake(false);        // change if necessary
      }
	
	
      /**
      * default propagation on instantiation: full constraint re-propagation
      * @param var index of the variable to reduce
      */
      public void awakeOnInst(int var) throws ContradictionException {
          constAwake(false);        // change if necessary
      }
	
      /**
      * default propagation on improved lower bound: propagation on domain revision
      * @param var index of the variable to reduce
      */
      public void awakeOnInf(int var) throws ContradictionException {
          constAwake(false);        // change if necessary
      }
	
	
      /**
      * default propagation on improved upper bound: propagation on domain revision
      * @param var index of the variable to reduce
      */
      public void awakeOnSup(int var) throws ContradictionException {
          constAwake(false);        // change if necessary
      }
	
      /**
      * default propagation on improve bounds: propagation on domain revision
      * @param var index of the variable to reduce
      */
      public void awakeOnBounds(int var) throws ContradictionException {
          constAwake(false);        // change if necessary
      }
	
      /**
      * default propagation on one value removal: propagation on domain revision
      * @param var index of the variable to reduce
      * @param val the removed value
      */
      public void awakeOnRem(int var, int val) throws ContradictionException {
          constAwake(false);        // change if necessary
      }
	
      /**
      * default propagation on one value removal: propagation on domain revision
      * @param var index of the variable to reduce
      * @param delta iterator over remove values
      */
      public void awakeOnRemovals(int var, IntIterator delta) throws ContradictionException {
          constAwake(false);        // change if necessary
      }
  }
\end{lstlisting}

The first step to create a constraint in Choco is to implement all \texttt{awakeOn...} methods with \texttt{constAwake(false)} and to put your propagation algorithm in the \texttt{propagate()} method. 

A constraint can choose not to react to fine grained events such as the removal of a value of a given variable but instead delay its propagation at the end of the fix point reached by ``fine grained events'' and fast constraints that deal with them incrementally (that's the purpose of the constraints events queue). 

To do that, you can use \texttt{constAwake(false)} that tells the solver that you want this constraint to be called only once the variables events queue is empty. This is done so that heavy propagators can delay their action after the fast one to avoid doing a heavy processing at each single little modification of domains.

\section{Define your own operator}\label{advanced:defineyourownoperator}\hypertarget{advanced:defineyourownoperator}{}
\todo{to complete}

%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%

There are 2 types of operators: \textbf{boolean} and \textbf{arithmetic}. These operators are based on integer variable and/or integer constants. 
Let's take 2 examples \textit{plus} and \textit{eq}.

The operator \textit{plus} is an arithmetic one (see  \mylst{PlusNode.java} class for details) that computes the sum of two variables (and/or constants). It extends  \mylst{INode} (it can be part of an expression object) and implements  \mylst{ArithmNode} (it can be evaluated). So, required services are:

\begin{itemize}
\item a constructor. The type of operator should be defined using \mylst{CUSTOM}.
\begin{lstlisting}
public PlusNode(INode[] subt) {
	super(subt, NodeType.CUSTOM);
}
\end{lstlisting}
\item  \mylst{pretty()} : a pretty print of the operator
\begin{lstlisting}
public String pretty() {
        return "("+subtrees[0].pretty()+" + "+subtrees[1].pretty()+")";
    }
\end{lstlisting}

\item  \mylst{eval(int[] tuple)} : evaluation of the operator with the given tuple. An arithmetic evaluation of the subtrees is done (based on the given tuple) to compute the sub expression before evaluating the current operator \textit{plus}. This allows tree-like representation of an expression.
\begin{lstlisting}
public int eval(int[] tuple) {
		return ((ArithmNode) subtrees[0]).eval(tuple) + ((ArithmNode) subtrees[1]).eval(tuple);
}
\end{lstlisting}
\end{itemize}


The operator \textit{eq} is a boolean one (see  \mylst{EqNode.java} class for more details) that checks if two variables (and/or constants) are equal. It extends  \mylst{AbstractBooleanNode} (that can be checked). So required services are:
\begin{itemize}
\item a constructor
\begin{lstlisting}
public EqNode(INode[] subt) {
        super(subt, NodeType.CUSTOM);
    }
\end{lstlisting}
\item  \mylst{pretty()} : a pretty print of the operator
\begin{lstlisting}
public String pretty() {
        return "("+subtrees[0].pretty()+"="+subtrees[1].pretty()+")";
}
\end{lstlisting} 

\item  \mylst{eval(int[] tuple)}: an expression checker, based on the given tuple. An arithmetic evaluation of the subtrees is done (based on the given tuple) in order to check the operator \textit{eq}.
\begin{lstlisting}
public boolean checkTuple(int[] tuple) {
		return ((ArithmNode) subtrees[0]).eval(tuple)
		        ==  ((ArithmNode) subtrees[1]).eval(tuple);
	}
\end{lstlisting}

\item  \mylst{extractConstraint(Solver s)} : extracts the corresponding constraint in intension constraint without reification.
\begin{lstlisting}
public SConstraint extractConstraint(Solver s) {
        IntDomainVar v1 = subtrees[0].extractResult(s);
		IntDomainVar v2 = subtrees[1].extractResult(s);
		return s.eq(v1,v2);
    }
\end{lstlisting}
\end{itemize}
Now let's see how to use this operator in a Model.

To do that, create your own manager implementing \mylst{ExpressionManager}, which makes the link between the model and the solver.

Then to use your operator in your model, you can define a static method to simplify the calls.

Let's sum up in a short example based on the \textit{plus} operator. 

The manager would be:
\begin{lstlisting}
public class PlusManager implements ExpressionManager {
    @Override
    public INode makeNode(Solver solver, Constraint[] cstrs, Variable[] vars) {
        if(solver instanceof CPSolver){
            CPSolver s = (CPSolver)solver;
            if(vars.length == 1){
                INode[] nodes = new INode[vars.length];
                for(int v = 0; v < vars.length; v++){
                    nodes[v] = vars[v].getExpressionManager().makeNode(s, vars[v].getConstraints(), vars[v].getVariables());
                }
                return new PlusNode(nodes);
            }
        }
        throw new ModelException("Could not found a node manager in " + this.getClass() + " !");
    }
}
\end{lstlisting}


A main class would be:
\begin{lstlisting}
public class Sandbox {

    public static void main(String[] args) {
        model1();
    }

    public static IntegerExpressionVariable plus(IntegerVariable x){
        return new IntegerExpressionVariable(null, "package.of.PlusManager", x);
    }

    private static void model1() {
        Model m = new CPModel();
        IntegerVariable x = Choco.makeIntVar("x", 0, 5);
        IntegerVariable y = Choco.makeIntVar("y", 4, 8);
        IntegerVariable z = Choco.makeIntVar("z", 0, 10);
	
        // declare an expression using my operator
        IntegerExpressionVariable xx = plus(x,y);

        // and use it in common constraint
        m.addConstraint(Choco.eq(z, xx));

        Solver s = new CPSolver();
        s.read(m);

        ChocoLogging.toSolution();
        s.solveAll();
    }
}
\end{lstlisting}

Keep in mind that you can not define operators for set and real. 

%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%

\section{Define your own variable}\label{advanced:defineyourownvariable}\hypertarget{advanced:defineyourownvariable}{}
\todo{to complete}
\section{Backtrackable structures}\label{advanced:backtrackablestructures}\hypertarget{advanced:backtrackablestructures}{}
\todo{to complete}

\section{Logging System}\label{advanced:loggingsystem}\hypertarget{advanced:loggingsystem}{}

Choco logging system is based on the \texttt{java.util.logging} package and located in the package \texttt{common.logging}.
Most Choco abstract classes or interfaces propose a static field \texttt{LOGGER}.
The following figures present the architecture of the logging system with the default verbosity.

\insertGraphique{.3\linewidth}{media/logger-default.png}{Logger Tree with the default verbosity}

The shape of the node depicts the type of logger:
\begin{itemize}
	\item The \emph{house} loggers represent private loggers. Do not use directly these loggers because their level are low and all messages would always be displayed.
	\item The \emph{octagon} loggers represent critical loggers. These loggers are provided in the variables, constraints and search classes and could have a huge impact on the global performances.
	\item The \emph{box} loggers are provided for dev and users.
\end{itemize}
The color of the node gives its logging level with DEFAULT verbosity:
\texttt{Level.FINEST} (\textcolor{yellow}{gold}),
\texttt{Level.INFO} (\textcolor{orange}{orange}),
\texttt{Level.WARNING} (\textcolor{red}{red}).

\subsubsection{Verbosity and messages.}\label{advanced:verbosityandmessages}\hypertarget{advanced:verbosityandmessages}{}
The following table summarizes the verbosities available in choco: 

\begin{itemize}
	\item \textbf{OFF -- level 0:} Disable logging.
	\item \textbf{SILENT -- level 1:} Display only severe messages.
	\item \textbf{DEFAULT -- level 2:} Display informations on final search state.
		\begin{itemize}
			\item ON START
				\lstset{language={sh},columns=fixed}
\begin{lstlisting}
 ** CHOCO : Constraint Programming Solver
 ** CHOCO v2.1.1 (April, 2009), Copyleft (c) 1999-2010
 \end{lstlisting}
			\item ON COMPLETE SEARCH:
				\begin{lstlisting}
- Search completed -
 [Maximize		: {0},]
 [Minimize		: {1},]
  Solutions		: {2},
  Times (ms)	: {3},
  Nodes			: {4},
  Backtracks	: {5},
  Restarts		: {6}.
  \end{lstlisting}
	brackets [\textit{line}] indicate \textit{line} is optionnal,\\
 	\texttt{Maximize} --resp. \texttt{Minimize}-- indicates the best known value before exiting of the objective value in \textit{maximize()} -- --resp. \textit{minimize()}-- strategy.

			\item ON COMPLETE SEARCH WITHOUT SOLUTIONS :
				\begin{lstlisting}
- Search completed - No solutions
 [Maximize		: {0},]
 [Minimize		: {1},]
  Solutions		: {2},
  Times (ms)	: {3},
  Nodes			: {4},
  Backtracks	: {5},
  Restarts		: {6}.
\end{lstlisting}
	brackets [\textit{line}] indicate \textit{line} is optionnal,\\
 	\texttt{Maximize} --resp. \texttt{Minimize}-- indicates the best known value before exiting of the objective value in \textit{maximize()} -- --resp. \textit{minimize()}-- strategy.

			\item ON INCOMPLETE SEARCH:
				\begin{lstlisting}
- Search incompleted - Exiting on limit reached
  Limit			: {0},
 [Maximize		: {1},]
 [Minimize		: {2},]
  Solutions		: {3},
  Times (ms)	: {4},
  Nodes			: {5},
  Backtracks	: {6},
  Restarts		: {7}.
  
  \end{lstlisting}
	brackets [\textit{line}] indicate \textit{line} is optionnal,\\
 	\texttt{Maximize} --resp. \texttt{Minimize}-- indicates the best known value before exiting of the objective value in \textit{maximize()} -- --resp. \textit{minimize()}-- strategy.
		\end{itemize}			

	\item \textbf{VERBOSE -- level 3:} Display informations on search state.
		\begin{itemize}
			\item EVERY X (default=1000) NODES:
			\begin{lstlisting}
- Partial search - [Objective : {0}, ]{1} solutions, {2} Time (ms), {3} Nodes, {4} Backtracks, {5} Restarts.
			\end{lstlisting}
			\texttt{Objective} indicates the best known value.

			\item ON RESTART : 
			\begin{lstlisting}
- Restarting search - {0} Restarts.
			\end{lstlisting}
		\end{itemize}

	\item \textbf{SOLUTION -- level 4:} display all solutions.
		\begin{itemize}
			\item AT EACH SOLUTION:
			\begin{lstlisting}
- Solution #{0} found. [Objective: {0}, ]{1} Solutions, {2} Time (ms), {3} Nodes, {4} Backtracks, {5} Restarts.
  X_1:v1, x_2:v2...
			\end{lstlisting}
		\end{itemize}

	\item \textbf{SEARCH -- level 5:} Display the search tree.
		\begin{itemize}
			\item AT EACH NODE, ON DOWN BRANCH:
			\begin{lstlisting}
...[w] down branch X==v branch b
			\end{lstlisting}
where \texttt{w} is the current world index, \texttt{X} the branching variable, \texttt{v} the branching value and \texttt{b} the branch index. This message can be adapted on variable type and search strategy.

			\item AT EACH NODE, ON UP BRANCH:
			\begin{lstlisting}
...[w] up branch X==v branch b
			\end{lstlisting}
where \texttt{w} is the current world index, \texttt{X} the branching variable, \texttt{v} the branching value and \texttt{b} the branch index. This message can be adapted on variable type and search strategy.
		\end{itemize}

	\item \textbf{FINEST -- level 6:} display all logs.

\end{itemize}

More precisely, if the verbosity level is greater than DEFAULT, then the verbosity levels of the model and of the solver are increased to INFO, and the verbosity levels of the search and of the branching are slightly modified to display the solution(s) and search messages.

The verbosity level can be changed as follows:
\begin{lstlisting}
	ChocoLogging.setVerbosity(Verbosity.VERBOSE);
\end{lstlisting}


\subsubsection{How to write logging statements ?}\label{advanced:howtowriteloggingstatements}\hypertarget{advanced:howtowriteloggingstatements}{}

\begin{itemize}
	\item Critical Loggers are provided to display error or warning. Displaying too much message really \textbf{impacts the performances}.
	\item Check the logging level before creating arrays or strings.
	\item Avoid multiple calls to \texttt{Logger} functions. Prefer to build a \texttt{StringBuilder} then call the \texttt{Logger} function.
	\item Use the \texttt{Logger.log} function instead of building string in \texttt{Logger.info()}.
\end{itemize}

\subsubsection{Handlers.}\label{advanced:handlers}\hypertarget{advanced:handlers}{}
Logs are displayed on \texttt{System.out} but warnings and severe messages are also displayed on \texttt{System.err}.
\texttt{ChocoLogging.java} also provides utility functions to easily change handlers:
\begin{itemize}
	\item Functions \texttt{set...Handler} remove current handlers and replace them by a new handler.
	\item Functions \texttt{add...Handler} add new handlers but do not touch existing handlers.
\end{itemize}

\subsubsection{Define your own logger.}\label{advanced:defineyourownlogger}\hypertarget{advanced:defineyourownlogger}{}
\begin{lstlisting}
ChocoLogging.makeUserLogger(String suffix);
\end{lstlisting}

% \subsubsection{Figure source}\label{advanced:figuresource}\hypertarget{advanced:figuresource}{}
% \begin{lstlisting}
%   digraph G {
%       node [style=filled, shape=box];
%       choco [shape=house,fillcolor=gold];
	
%       kernel [shape=house,fillcolor=gold];
%       engine [shape=octagon,fillcolor=indianred];
%       search [shape=octagon,fillcolor=darkorange];
%       branching [shape=octagon,fillcolor=indianred];
	
%       api [shape=house,fillcolor=gold];
%       model [fillcolor=indianred];
%       solver [fillcolor=indianred];
%       parser [fillcolor=darkorange];
      
%       user [fillcolor=darkorange];
%       samples [fillcolor=darkorange];
      
%       test [fillcolor=indianred];
      
%       choco -> kernel;
%       choco -> API;
%       choco -> user;
%       choco -> test;
      
%       kernel -> engine;
%       kernel -> search;
      
%       api -> model;
%       api -> solver
%       api -> parser;
      
%       user  -> samples;
      
%       search -> branching;
% 	}
% \end{lstlisting}
