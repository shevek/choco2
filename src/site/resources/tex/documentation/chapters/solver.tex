%\part{solver}
\label{solver}
\hypertarget{solver}{}


\chapter{The solver}\label{solver:thesolver}\hypertarget{solver:thesolver}{}

%\section{How to create a solver}\label{solver:howtocreateasolver}\hypertarget{solver:howtocreateasolver}{}


\newglossaryentry{Solver}{name={Solver},description={solver description}}

To create a \gls{Solver}, one just needs to create a new object as follow:
\begin{lstlisting}
Solver solver = new CPSolver();
\end{lstlisting}
By this, a Constraint Programming (CP) {\tt Solver} object is created. 

%\section{Read a model}\label{solver:readamodel}\hypertarget{solver:readamodel}{}
The solver gives an API to read a model. The reading of a model is compulsory and must be done after the entire definition of the model. 
\begin{lstlisting}
solver.read(model);
\end{lstlisting}
The reading is divided in 2 parts: \hyperlink{solver:variablesreading}{variables reading} and \hyperlink{solver:constraintsreading}{constraints reading}.

\section{Variables reading}\label{solver:variablesreading}\hypertarget{solver:variablesreading}{}
The solver iterates over the variables of the Model to create solver-specific variables and domains (as defined in the model). 
Thus, three types of variables can be created: integer variables, real variables and set variables. 
Depending on the constructor, the correct domain is created (like bounded domain or enumerated domain for integer variables). 

\begin{note}
\textbf{Bound variables} are related to large domains which are only represented by their lower and upper bounds. The domain is encoded in a space efficient way and propagation events only concern bound updates. Value removals between the bounds are therefore ignored (\emph{holes} are not considered). The level of consistency achieved by most constraints on these variables is called \emph{bound-consistency}.

On the contrary, the domain of an \textbf{enumerated variable} is explicitly represented and every value is considered while pruning. Basic constraints are therefore often able to achieve \emph{arc-consistency} on enumerated variables (except for NP global constraint such as the cumulative constraint). Remember that switching from an enumerated variable to a bounded variables decrease the level of propagation achieved by the system.
\end{note}

%\begin{note}
\textbf{Model variables and Solver variables are distinct objects}. Solver variables are solver representation of the model variables. One can't access to variable value directly from the model variable. To access to a model variable thanks to the solver, use the following \texttt{Solver} API: \mylst{getVar(Variable v);}
%\end{note}

\subsection{Solver and IntegerVariables}\label{solver:solverandintegervariables}\hypertarget{solver:solverandintegervariables}{}

A model integer variable can be accessed by the method \textbf{\tt getVar(IntegerVariable v)} which returns a \textbf{\tt IntDomainVar} object:
\begin{lstlisting}
  IntegerVariable x = makeEnumIntVar("x", 1, 100);  // model variable
  IntDomainVar xOnSolver = solver.getVar(x);  // solver variable
\end{lstlisting}

The state of an \texttt{IntDomainVar} can be accessed through the main following public methods :

\noindent\begin{tabular}{p{.3\linewidth}p{.7\linewidth}}
  \hline
  \texttt{IntDomainVar} API &  description \\
  \hline
	\mylst{hasEnumeratedDomain()} &checks if the variable is an enumerated or a bound one\\
	\mylst{getInf()} &returns the lower bound of the variable\\
	\mylst{getSup()} &returns the upper bound of the variable\\
	\mylst{getVal()} &returns the value if it is instantiated\\
	\mylst{isInstantiated()} &checks if the domain is reduced to a singleton\\
	\mylst{canBeInstantiatedTo(int v)} &checks if the value \emph{v} is contained in the domain of the variable\\
	\mylst{getDomainSize()} &returns the current size of the domain\\
  \hline\\
\end{tabular}

For more informations on advanced uses of such \texttt{IntDomainVar}, see \hyperlink{advanced}{advanced uses}.

\subsection{Solver and SetVariables}\label{solver:solverandsetvariables}\hypertarget{solver:solverandsetvariables}{}

A model set variable can be access by the method \textbf{\tt getVar(SetVariable v)} which returns a \textbf{\tt SetVar} object:
\begin{lstlisting}
	SetVariable x = makeBoundSetVar("x", 1, 40); // model variable
	SetVar xOnSolver = solver.getVar(x); // solver variable
\end{lstlisting}
A set variable on integer values between $[1,n]$ has $2^{n}$ values (every possible subsets of $\{1..n\}$). This makes an exponential number of values and the domain is represented with two bounds corresponding to the intersection of all possible sets (called the kernel) and the union of all possible sets (called the envelope) which are the possible candidate values for the variable.

The state of a \texttt{SetVar} can be accessed through the main following public methods on the SetVar class:

\noindent\begin{tabular}{p{.3\linewidth}p{.7\linewidth}}
  \hline
  \texttt{SetVar} API &  description \\
  \hline
	\mylst{getCard()} &returns the \texttt{IntDomainVar} representing the cardinality of the set variable\\
	\mylst{isInDomainKernel(int v)} &checks if value \emph{v} is contained in the current kernel\\
	\mylst{isInDomainEnveloppe(int v)} &checks if value \emph{v} is contained in the current envelope\\
	\mylst{getDomain()} &returns the domain of the variable as a \texttt{SetDomain}. Iterators on envelope or kernel can than be called\\
	\mylst{getKernelDomainSize()} &returns the size of the kernel\\
	\mylst{getEnveloppeDomainSize()} &returns the size of the envelope\\
	\mylst{getEnveloppeInf()} &returns the first available value of the envelope\\
	\mylst{getEnveloppeSup()} &returns the last available value of the envelope\\
	\mylst{getKernelInf()} &returns the first available value of the kernel\\
	\mylst{getKernelSup()} &returns the last available value of the kernel\\
	\mylst{getValue()} &returns a table of integers \texttt{int[]} containing the current domain\\
  \hline\\
\end{tabular}


For more informations on advanced uses of such \texttt{SetVar}, see \hyperlink{advanced}{advanced uses}.

\subsection{Solver and RealVariables}\label{solver:solverandrealvariables}\hypertarget{solver:solverandrealvariables}{}

\begin{note}
\emph{Real variables are still under development but can be used to solve toy problems such as small systems of equations.}
\end{note}
 
A model real variable can be access by the method \textbf{\tt getVar(RealVariable v)} which returns a \texttt{RealVar} object:
\begin{lstlisting}
	RealVariable x = makeRealVar("x", 1.0, 3.0); // model variable
	RealVar xOnSolver = s.getVar(x); // solver variable
\end{lstlisting}

Continuous variables are useful for non linear equation systems which are encountered in physics for example.

\noindent\begin{tabular}{p{.3\linewidth}p{.7\linewidth}}
  \hline
  \texttt{RealVar} API &  description \\
  \hline
	\mylst{getInf()} &returns the lower bound of the variable (\texttt{double})\\
	\mylst{getSup()} &returns the upper bound of the variable (\texttt{double})\\
	\mylst{isInstantiated()} &checks if the domain of a variable is reduced to a canonical interval. A canonical interval indicates that the domain has reached the precision given by the user or the solver\\
  \hline\\
\end{tabular}


For more informations on advanced uses of such \texttt{RealVar}, see \hyperlink{advanced}{advanced uses}.

\section{Constraints reading}\label{solver:constraintsreading}\hypertarget{solver:constraintsreading}{}
Once variables are known, the Solver iterates over the constraints of the Model, creates Solver constraint objects and add it the internal constraint network. Each Solver's constraint encapsulates a filtering algorithm which is called when a propagation step occurs or when external events happen on the variables belonging to the constraint, such as value removals or bounds modifications. 

\section{Search Strategy}\label{solver:searchstrategy}\hypertarget{solver:searchstrategy}{}

\newglossaryentry{branching strategy}{name={branching strategy}, plural={branching strategies},description={heuristic controlling the execution of a search loop at a point where the control flow may be split between different branches}}
\newglossaryentry{search strategy}{name={search strategy}, plural={search strategies},description={composition of branching strategies}}

A key ingredient of any constraint approach is a clever \gls{search strategy}. The construction of the search tree is done according to a series of \glspl{branching strategy} that plays the role of achieving intermediate goals in logic programming. The user may specify the sequence of branching strategies to be used to build the search tree. We will present in this section how to define your branching strategies.

\subsection{Override the default search stragtegy}\label{solver:overridethedefaultsearchstrategy}\hypertarget{solver:overridethedefaultsearchstrategy}{}

\newglossaryentry{value selector}{name={value selector}, plural={value selector},description={heuristic specifying how to choose dynamically a value from a chosen variable at a fix point}}
\newglossaryentry{value iterator}{name={value iterator}, plural={value iterators},description={heuristic specifying how to choose a value from a chosen variable, through an iterator, at a fix point }}
\newglossaryentry{variable selector}{name={variable selector}, plural={variable selectors},description={heuristic specifying how to choose a variable at a fix point}}


Basically, a search strategy is the composition of three objects: a \gls{branching strategy}, a \gls{variable selector} and a \gls{value selector} (or a \gls{value iterator}). Some branching strategies simply assign a selected value to a selected variable, like \hyperlink{assignvar:assignvarbranchstrat}{AssignVar}, others branching strategies embed the variable selector, like \hyperlink{domoverwdeg:domoverwdegbranchstrat}{DomOverWDegBranchingNew}, or more, like  \hyperlink{impact:impactbranchstrat}{ImpactBasedBranching}.

The default search strategies are: 

\noindent\begin{tabular}{p{.4\linewidth}p{.6\linewidth}}
\hline
Variable &  Default strategy \\
\hline
Integer & \hyperlink{domoverwdeg:domoverwdegbranchstrat}{DomOverWDegBranchingNew} +\hyperlink{increasingdomain:increasingdomainvaliterator}{IncreasingDomain}\\
Set &   \hyperlink{assignsetvar:assignsetvarbranchstrat}{AssignSetVar} + \hyperlink{mindomset:mindomsetvarselector}{MinDomainSet} + \hyperlink{minenv:minenvvalselector}{MinEnv} \\
 Real &  \hyperlink{assigninterval:assignintervalbranchstrat}{AssignInterval} + \hyperlink{cyclicrealvarselector:cyclicrealvarselectorvarselector}{CyclicRealVarSelector}+ \hyperlink{realincreasingdomain:realincreasingdomainvaliterator}{RealIncreasingDomain} \\
\hline\\
\end{tabular}

There are two ways to custom a search strategy: use one og those define in the factory \texttt{BranchingFactory} or build your own one. 
A branching strategy can be added the following API (must be done before calling the resolution method):

\begin{lstlisting}
solver.addGoal(AbstractIntBranchingStrategy branching);
\end{lstlisting}
The initial list of goals is empty. If no goal is defined, default ones will be build from the current state of the Solver.
\noindent To clear the list of goals, use:
\begin{lstlisting}
solver.clearGoals();
\end{lstlisting} 

The following example add three branching objects on integer variables \emph{vars1}, \emph{vars2} and set variables \emph{svars} to solver \emph{s}. The first two branchings are both \texttt{AssignVar} but use two different variable/values selection strategies:
\begin{lstlisting}
  s.addGoal(new AssignVar(new MinDomain(s,s.getVar(vars1)), new IncreasingDomain()));
  s.addGoal(new AssignVar(new DomOverDeg(s,s.getVar(vars2)),new DecreasingDomain());
  s.addGoal(new AssignSetVar(new MinDomSet(s,s.getVar(svars)), new MinEnv(s)));
  s.solve();
\end{lstlisting}

\begin{note}
Strategies are made of \texttt{Solver} variables (not \texttt{Model} variables).
\end{note}

\subsubsection{Branching strategy.}\label{solver:branchstrat}\hypertarget{solver:branchstrat}{}
It defines the way to take a decision in a tree search node.
  
\noindent The \textbf{branching strategies} currently available in Choco are the following: 
\begin{notedef}\tt
\hyperlink{assigninterval:assignintervalbranchstrat}{AssignInterval}, \hyperlink{assignorforbidintvarval:assignorforbidintvarvalbranchstrat}{AssignOrForbidIntVarVal}, \hyperlink{assignorforbidintvarvalpair:assignorforbidintvarvalpairbranchstrat}{AssignOrForbidIntVarValPair}, \hyperlink{assignsetvar:assignsetvarbranchstrat}{AssignSetVar}, \hyperlink{assignvar:assignvarbranchstrat}{AssignVar}, \hyperlink{domoverwdeg:domoverwdegbranchstrat}{DomOverWDegBranchingNew}, \hyperlink{domoverwdegbin:domoverwdegbinbranchstrat}{DomOverWDegBinBranchingNew}, \hyperlink{impact:impactbranchstrat}{ImpactBasedBranching}, \hyperlink{packdynremovals:packdynremovalsbranchstrat}{PackDynRemovals}, \hyperlink{settimes:settimesbranchstrat}{SetTimes}, \hyperlink{taskdomoverwdeg:taskdomoverwdegbranchstrat}{TaskOverWDegBinBranching}.
\end{notedef}    


\subsubsection{Variable selector.}\label{solver:variableselector}\hypertarget{solver:variableselector}{}
It defines the way to choose the non instantiated variable on which the next decision will be made.

\noindent The \textbf{integer variable selectors} currently available in Choco are the following: 
\begin{notedef}\tt
\hyperlink{compositeintvarselector:compositeintvarselectorvarselector}{CompositeIntVarSelector}, \hyperlink{lexintvarselector:lexintvarselectorvarselector}{LexIntVarSelector}, \hyperlink{maxdomain:maxdomainvarselector}{MaxDomain}, \hyperlink{maxregret:maxregretvarselector}{MaxRegret}, \hyperlink{maxvaldomain:maxvaldomainvarselector}{MaxValueDomain}, \hyperlink{mindomain:mindomainvarselector}{MinDomain}, \hyperlink{minvaldomain:minvaldomainvarselector}{MinValueDomain}, \hyperlink{mostconstrained:mostconstrainedvarselector}{MostConstrained},  \hyperlink{randomvarint:randomvarintvarselector}{RandomIntVarSelector},  \hyperlink{staticvarorder:staticvarordervarselector}{StaticVarOrder}
\end{notedef}

\noindent The \textbf{set variable selectors} currently available in Choco are the following: 
\begin{notedef}\tt
\hyperlink{maxdomset:maxdomsetvarselector}{MaxDomainSet}, \hyperlink{maxregretset:maxregretsetvarselector}{MaxRegretSet}, \hyperlink{maxvaldomainset:maxvaldomainsetvarselector}{MaxValueDomainSet}, \hyperlink{mindomset:mindomsetvarselector}{MinDomainSet}, \hyperlink{minvaldomainset:minvaldomainsetvarselector}{MinValueDomainSet}, \hyperlink{mostconstrainedset:mostconstrainedsetvarselector}{MostConstrainedSet},  \hyperlink{randomvarset:randomvarsetvarselector}{RandomSetVarSelector},  \hyperlink{staticsetvarorder:staticsetvarordervarselector}{StaticSetVarOrder}
\end{notedef}

\noindent The \textbf{real variable selector} currently available in Choco is the following: 
\begin{notedef}\tt
\hyperlink{cyclicrealvarselector:cyclicrealvarselectorvarselector}{CyclicRealVarSelector}
\end{notedef}

\subsubsection{Value iterator}\label{solver:valueiterator}\hypertarget{solver:valueiterator}{}
Once the variable has been choosen, the Solver has to compute its value. The first way to do it is to schedule the value once and give an iterator to the solver.

\noindent The \textbf{integer value iterator} currently available in Choco are the following: 
\begin{notedef}\tt
\hyperlink{decreasingdomain:decreasingdomainvaliterator}{DecreasingDomain}, \hyperlink{increasingdomain:increasingdomainvaliterator}{IncreasingDomain}
\end{notedef}

\noindent The \textbf{real value iterator} currently available in Choco is the following: 
\begin{notedef}\tt
\hyperlink{realincreasingdomain:realincreasingdomainvaliterator}{RealIncreasingDomain}
\end{notedef}




\subsubsection{Value selector}\label{solver:valueselector}\hypertarget{solver:valueselector}{}
The second way to do it is to compute the following value at each call.

\noindent The \textbf{integer value selector} currently available in Choco are the following: 
\begin{notedef}\tt
\hyperlink{bestfit:bestfitvalselector}{BestFit}, \hyperlink{costregularvalselector:costregularvalselectorvalselector}{CostRegularValSelector}, \hyperlink{fcostregularvalselector:fcostregularvalselectorvalselector}{FCostRegularValSelector}, \hyperlink{maxval:maxvalvalselector}{MaxVal}, \hyperlink{mcrvalselector:mcrvalselectorvalselector}{MCRValSelector}, \hyperlink{midval:midvalvalselector}{MidVal}, \hyperlink{minval:minvalvalselector}{MinVal}
\end{notedef}

\noindent The \textbf{set value selector} currently available in Choco is the following: 
\begin{notedef}\tt
\hyperlink{minenv:minenvvalselector}{MinEnv}, \hyperlink{randomsetvalselector:randomsetvalselectorvalselector}{RandomSetValSelector}
\end{notedef}

\subsection{Why is it important to define a search strategy ?}\label{solver:whyisitimportanttodefineasearchstrategy}\hypertarget{solver:whyisitimportanttodefineasearchstrategy}{}

In a partial instantiation, when a fix point has been reached, the Solver needs to take a decision to resume the search. The way decisions are chosen has a \textbf{real impact on the resolution step efficient}. 
\begin{note}
\emph{The search strategy should not be overlooked!!}
An adapted search strategy can reduce: the execution time, the number of node expanded, the number of backtrack done.
\end{note}
Let see that small example:
\begin{lstlisting}
	Model m = new CPModel();
        int n = 1000;
        IntegerVariable var = Choco.makeIntVar("var", 0, 2);
        IntegerVariable[] bi = Choco.makeBooleanVarArray("b", n);
        m.addConstraint(Choco.eq(var, Choco.sum(bi)));

        Solver badStrat = new CPSolver();
        badStrat.read(m);
        badStrat.addGoal(
                new AssignVar(
                        new MinDomain(badStrat), 
                        new IncreasingDomain()
                ));
        badStrat.solve();
        badStrat.printRuntimeStatistics();

        Solver goodStrat = new CPSolver();
        goodStrat.read(m);
        goodStrat.addGoal(
                new AssignVar(
                        new MinDomain(goodStrat, goodStrat.getVar(new IntegerVariable[]{var})), 
                        new DecreasingDomain()
                ));
        goodStrat.solve();
        goodStrat.printRuntimeStatistics();
\end{lstlisting}

This model ensures that $var = b_{0} + b_{1} + \ldots + b_{1000}$ where \emph{var} has a small domain and $b_{i}$ is a binary variable. The propagation has no effect on any domain and a fix point is reached at the beginning of the search. So, a decision has to be done choosing a variable and its value. If the variable selector is set to \texttt{MinDomain} (see below), the solver will iterate over the variables, starting by the 1000 binary variables and ending with \emph{var}, and 1001 nodes will be created.

\subsection{Restarts}\label{solver:restarts}\hypertarget{solver:restarts}{}

You can set geometric restarts by using the following API available on the solver:
\begin{lstlisting}
setGeometricRestart(int base, double grow);
setGeometricRestart(int base, double grow, int restartLimit);
\end{lstlisting}
It performs a search with restarts regarding the number of backtrack. An initial allowed number of backtrack is given (parameter base) and once this limit is reached a restart is performed and the new limit imposed to the search is increased by multiplying the previous limit with the parameter grow. restartLimit parameter states the maximum number of restarts. Restart strategies makes really sense with strategies that make choices based on the past experience of the search : \texttt{DomOverWdeg} or Impact based search. It could also be used with a random heuristic
\begin{lstlisting}
	CPSolver s = new CPSolver();
	s.read(model);
	
	s.setGeometricRestart(14, 1.5d);
	s.setFirstSolution(true);
	s.generateSearchStrategy();
	s.attachGoal(new DomOverWDegBranching(s, new IncreasingDomain()));
	s.launch();
\end{lstlisting}

You can also set Luby restarts by using the following API available on the solver:
\begin{lstlisting}
setLubyRestart(int base);
setLubyRestart(int base, int grow);
setLubyRestart(int base, int grow, int restartLimit);
\end{lstlisting}
it performs a search with restarts regarding the number of backtracks. One way to describe this strategy is to say that all run lengths are power of two, and that each time a pair of runs of a given length has been completed, a run of twice that length is immediatly executed. The limit is equals to \emph{length*base}.
\begin{itemize}
	\item \textbf{example with growing factor of 2 : [1, 1, 2, 1, 1, 2, 4, 1, 1, 2, 1, 1, 2, 4, 8, 1,...]}
	\item \textbf{example with growing factor of 3 : [1, 1, 1, 3, 1, 1, 1, 3, 9,...]}
\end{itemize}

\begin{lstlisting}
	CPSolver s = new CPSolver();
	s.read(model);
	
	s.setLubyRestart(50, 2, 100);
	s.setFirstSolution(true);
	s.generateSearchStrategy();
	s.attachGoal(new DomOverWDegBranching(s, new IncreasingDomain()));
	s.launch();
\end{lstlisting}

\section{Limiting Search Space}\label{solver:limitingsearchspace}\hypertarget{solver:limitingsearchspace}{}
The Solver class provides some limits on the search strategy that you can fix or just monitor.
Limits may be imposed on the search algorithm to avoid spending too much time in the exploration. The limits are updated and checked each time a new node is created. It has to be specified before the resolution. 
After having created the solver, you can specify whether or not you want to fix a limit:

\begin{description}
\item[time limit] State a time limit on tree search. When the execution time is equal to the time limit, the search stops whatever a solution is found or not. You can define a time limit with the following API : \mylst{setTimeLimit(int timeLimit)} where unit is millisecond. Or just monitor (or not) the search time with the API : \mylst{monitorTimeLimit(boolean b)}. The default value is set to \texttt{true}. Finally, you can get the time limit, once the solve method has been called, with the API: \mylst{getTimeCount()} 
\item[node limit] State a node limit on tree search. When the number of nodes explored is equal to the node limit, the search stops whatever a solution is found or not. You can define a node limit with the following API: \mylst{setNodeLimit(int nodeLimit)} where unit is the number of nodes. Or just monitor (or not) the number of nodes explored with the API: \mylst{monitorNodeLimit(boolean b)}. The default value is set to \texttt{true}. Finally, you can get the node limit, once the solve method has been called, with the API: \mylst{getNodeCount()} 
\item[backtrack limit] State a backtrack limit on tree search. When the number of backtracks done is equal to the backtrack limit, the search stops whatever a solution is found or not. You can define a backtrack limit with the following API: \mylst{setBackTrackLimit(int backtrackLimit)} where unit is the number of backtracks. Or just monitor (or not) the number of backtrack done with the API: \mylst{monitorBackTrackLimit(boolean b)}. The default value is set to \texttt{false}. Finally, you can get the backtrack limit, once the solve method has been called, with the API: \mylst{getBackTrackCount()} 
\item[fail limit] State a fail limit on tree search. When the number of failure is equal to the fail limit, the search stops whatever a solution is found or not. You can define a fail limit with the following API : \mylst{setFailLimit(int failLimit)} where unit is the number of failure. Or just monitor (or not) the number of failure encountered with the API : \mylst{monitorFailLimit(boolean b)}. The default value is set to \texttt{false}. Finally, you can get the fail limit, once the solve method has been called, with the API : \mylst{getFailCount()} 
%\item[CPU time limit] State a CPU limit on tree search. When the CPU time (user + system) is equal to the CPU time limit, the search stops whatever a solution is found or not. You can define a CPU time limit with the following API: \mylst{setCpuTimeLimit(int timeLimit)} where unit is millisecond. Or just monitor (or not) the search time with the API: \mylst{monitorCpuTimeLimit(boolean b)}. The default value is set to \texttt{false}. Finally, you can get the CPU time limit, once the solve method has been called, with the API: \mylst{getCpuTimeCount()} 
\end{description}

\todo{add example}

\section{Solve a problem}\label{solver:solveaproblem}\hypertarget{solver:solveaproblem}{}
As Solver is the second element of a Choco program, the control of the search process without using predefined tools is made on the Solver.

\noindent\begin{tabular}{p{.4\linewidth}p{.6\linewidth}}
  \hline
  \texttt{Solver} API & description \\
  \hline
      \mylst{solve()} &  Compute the first solution of the Model, if the Model is feasible. \\
      \mylst{solve(boolean all)} &  If \emph{all} is set to true, computes all solutions of the Model, if the Model is feasible. \\
      \mylst{solveAll()} &  Computes all the solution of the Model, if the Model is feasible. \\
      \mylst{propagate()} &  Computes initial propagation of the Model, and reachs the first Fix Point. It reduces variables Domain through constraints linked and other variables domain. Can throw a \texttt{ContradictionException} if the Solver detects a contradiction in the Model. \\
      \mylst{maximize(Var obj, boolean restart)} &  Allows user to find a solution that maximizing the objective varible \emph{obj}. The optimization finds a first solution then finds a new solution that improves \emph{obj} and so on till no other solution can be found that improves \emph{obj}. Parameter \emph{restart} is a boolean indicating whether the Solver will restart the search after each solution found (if set to \texttt{true}) or if it will keep backtracking from the leaf of the last solution found. See \hyperlink{solver:optimization}{example}. \textbf{Beware}: the variable \emph{obj} expected must be a Solver variable and not a Model variable. \\
      \mylst{minimize(Var obj, boolean restart)} &  Allows user to find a solution that minimizing the objective varible \emph{obj}. The optimization finds a first solution then finds a new solution that improves \emph{obj} and so on till no other solution can be found that improves \emph{obj}. Parameter \emph{restart} is a boolean indicating whether the Solver will restart the search after each solution found (if set to \texttt{true}) or if it will keep backtracking from the leaf of the last solution found. See \hyperlink{solver:optimization}{example}. \textbf{Beware}: the variable \emph{obj} expected must be a Solver variable and not a Model variable. \\
      \mylst{nextSolution()} &  Allows the Solver to find the next solution, if one or more solution have already been find with \texttt{solve()} or \texttt{nextSolution()}. \\
      \mylst{isFeasible()} &  Indicates whether or not the Model has at least one solution. \\
      \hline\\
	\end{tabular}

\subsection{Solver settings}\label{solver:solversettings}\hypertarget{solver:solversettings}{}

\subsubsection{Logs}\label{solver:logs}\hypertarget{solver:logs}{}
A logging class is instrumented in order to produce trace statements throughout search: ChocoLogging. The verbosity level of the solver can be set, by the following static method
\begin{lstlisting}
	ChocoLogging.toVerbose();
	// And after solver.solve()
	ChocoLogging.flushLogs();
\end{lstlisting}

The code above ensure that messages are printed in order to describe the construction of the search tree.

Six verbosity levels are available:

\noindent\begin{tabular}{p{.4\linewidth}p{.6\linewidth}}
  \hline
  Level & prints... \\
  \hline
 \texttt{ChocoLogging.toSilent()} & display only severe messages from core loggers and warning messages otherwise\\
 \ \texttt{ChocoLogging.toQuiet()} & display only severe messages from core loggers and info messages otherwise\\
 \texttt{ChocoLogging.toDefault()} & display information about initial and final state of the search\\
 \texttt{ChocoLogging.toVerbose()} & display search information at regular node intervals\\
 \texttt{ChocoLogging.toSolution()} & display all solutions\\
 \texttt{ChocoLogging.toSearch()} & display the search tree\\
\hline\\
\end{tabular}

Note that in the case of a verbosity greater or equals to \texttt{toVerbose()}, the regular search information step is set to 1000, by default. You can change this value, using:
\begin{lstlisting}
  ChocoLogging.setEveryXNodes(20000);
\end{lstlisting}
 

Note that in the case of verbosity \texttt{toSearch()}, trace statements are printed up to a maximal depth in the search tree. The default value is set to 25, but you can change the value of this threshold, say to 10, with the following setter method:
\begin{lstlisting}
  ChocoLogging.setLoggingMaxDepth(10);
\end{lstlisting}

\subsection{Optimization}\label{solver:optimization}\hypertarget{solver:optimization}{}
\todo{to introduce}
\begin{lstlisting}
  Model m = new CPModel();
  IntegerVariable obj1 = makeEnumIntVar("obj1", 0, 7);
  IntegerVariable obj2 = makeEnumIntVar("obj1", 0, 5);
  IntegerVariable obj3 = makeEnumIntVar("obj1", 0, 3);
  IntegerVariable cost = makeBoundIntVar("cout", 0, 1000000);
  int capacity = 34;
  int[] volumes = new int[]{7, 5, 3};
  int[] energy = new int[]{6, 4, 2};
  // capacity constraint
  m.addConstraint(leq(scalar(volumes, new IntegerVariable[]{obj1, obj2, obj3}), capacity));
	
  // objective function
  m.addConstraint(eq(scalar(energy, new IntegerVariable[]{obj1, obj2, obj3}), cost));
  
  Solver s = new CPSolver();
  s.read(m);
  
  s.maximize(s.getVar(cost), false);
\end{lstlisting}
