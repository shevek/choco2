%!TEX root = ../content-tut.tex
%\part{solutions}
\label{solutions}
\hypertarget{solutions}{}

\chapter{Solutions}\label{solutions:solutions}\hypertarget{solutions:solutions}{}

\section{I'm new to CP}\label{solutions:i'mnewtocp}\hypertarget{solutions:i'mnewtocp}{}

\subsection{Solution of Exercise 1.1 (A soft start)}\label{solutions:solutionofexercise1.1}\hypertarget{solutions:solutionofexercise1.1}{}
(\hyperlink{exercises:exercise1.1}{Problem})

\noindent\emph{\textbf{Question 1}: describe the constraint network related to code}

The model is defined as :
\begin{itemize}
	\item $V = \{x_1, x_2, x_3\}$: the set of variables,
	\item $D = \{[0,5], [0,5], [0,5]\}$: the set of domain
	\item $C = \{x_1>x_2, x_1\neq x_3, x_2>x_3\}$: the set of constraints.
\end{itemize}

\noindent\emph{\textbf{Question 2}: give the variable domains after constraint propagation.}

\begin{itemize}
	\item From $x_1 = [0,5]$ and $x_2 = [0,5]$ and $x_1>x_2$, we can deduce tha : the domain of $x_1$ can be reduce to $[1,5]$ and the domain of $x_2$ can be reduce to $[0,4]$.
	\item Then, from $x_2 = [0,4]$ and $x_3 = [0,5]$ and $x_2>x_3$, we can deduce that : the domain of $x_2$ can be reduce to $[1,4]$ and the domain of $x_3$ can be reduce to $[0,3]$.
	\item Then, from $x_1 = [1,5]$ and $x_2 = [1,4]$ and $x_1>x_2$, we can deduce that : the domain of $x_1$ can be reduce to $[2,5]$.
\end{itemize}

We cannot deduce anything else, so we have reached a \textbf{fix point}, and here is the domain of each variables:
$$x_{1} : [2,5],\quad x_{2} : [1,4],\quad x_{3} : [0,3].$$


\subsection{Solution of Exercise 1.2 (DONALD + GERALD = ROBERT)}\label{solutions:solutionofexercise1.2}\hypertarget{solutions:solutionofexercise1.2}{}

(\hyperlink{exercises:exercise1.2}{Problem})

\begin{lstlisting}
  // Build model
  Model model = new CPModel();
  
  // Declare every letter as a variable
  IntegerVariable d = makeIntVar("d", 0, 9, Options.V_ENUM);
  IntegerVariable o = makeIntVar("o", 0, 9, Options.V_ENUM);
  IntegerVariable n = makeIntVar("n", 0, 9, Options.V_ENUM);
  IntegerVariable a = makeIntVar("a", 0, 9, Options.V_ENUM);
  IntegerVariable l = makeIntVar("l", 0, 9, Options.V_ENUM);
  IntegerVariable g = makeIntVar("g", 0, 9, Options.V_ENUM);
  IntegerVariable e = makeIntVar("e", 0, 9, Options.V_ENUM);
  IntegerVariable r = makeIntVar("r", 0, 9, Options.V_ENUM);
  IntegerVariable b = makeIntVar("b", 0, 9, Options.V_ENUM);
  IntegerVariable t = makeIntVar("t", 0, 9, Options.V_ENUM);
  
  // Declare every name as a variable  
  IntegerVariable donald = makeIntVar("donald", 0, 1000000,Options.V_BOUND);
  IntegerVariable gerald = makeIntVar("gerald", 0, 1000000,Options.V_BOUND);
  IntegerVariable robert = makeIntVar("robert", 0, 1000000,Options.V_BOUND);
  
  // Array of coefficients
  int[] c = new int[]{100000, 10000, 1000, 100, 10, 1}; 
  
  // Declare every combination of letter as an integer expression
  IntegerExpressionVariable donaldLetters = scalar(new IntegerVariable[]{d,o,n,a,l,d}, c);
  IntegerExpressionVariable geraldLetters = scalar(new IntegerVariable[]{g,e,r,a,l,d}, c);
  IntegerExpressionVariable robertLetters = scalar(new IntegerVariable[]{r,o,b,e,r,t}, c);
  
  // Add equality between name and letters combination
  model.addConstraint(eq(donaldLetters, donald));
  model.addConstraint(eq(geraldLetters, gerald));
  model.addConstraint(eq(robertLetters, robert));
  // Add constraint name sum
  model.addConstraint(eq(plus(donald, gerald), robert));
  // Add constraint of all different letters.
  model.addConstraint(allDifferent(new IntegerVariable[]{d,o,n,a,l,g,e,r,b,t}));
  
  // Build a solver, read the model and solve it
  Solver s = new CPSolver();
  s.read(model);
  s.solve();
  
  // Print name value
  System.out.println("donald = " + s.getVar(donald).getVal());
  System.out.println("gerald = " + s.getVar(gerald).getVal());
  System.out.println("robert = " + s.getVar(robert).getVal());
\end{lstlisting}

\subsection{Solution of Exercise 1.3 (A famous example. . . a sudoku grid)}\label{solutions:solutionofexercise1.3}\hypertarget{solutions:solutionofexercise1.3}{}

(\hyperlink{exercises:exercise1.3}{Problem})

\noindent\emph{\textbf{Question 1}: propose a way to model the sudoku problem with difference constraints. Implement your model with choco solver.}

\begin{lstlisting}
  int n = instance.length;
  // Build Model
  Model m = new CPModel();
  
  // Build an array of integer variables
  IntegerVariable[][] rows = makeIntVarArray("rows", n, n, 1, n,Options.V_ENUM);
	
  // Not equal constraint between each case of a row
  for (int i = 0; i < n; i++) {
      for (int j = 0; j < n; j++)
          for (int k = j; k < n; k++)
              if (k != j) m.addConstraint(neq(rows[i][j], rows[i][k]));
  }
                  
  // Not equal constraint between each case of a column
  for (int j = 0; j < n; j++) {
      for (int i = 0; i < n; i++)
          for (int k = 0; k < n; k++)
              if (k != i)  m.addConstraint(neq(rows[i][j], rows[k][j]));
  }

  // Not equal constraint between each case of a sub region
  for (int ci = 0; ci < n; ci += 3) {
      for (int cj = 0; cj < n; cj += 3)
          // Extraction of disequality of a sub region
          for (int i = ci; i < ci + 3; i++)
              for (int j = cj; j < cj + 3; j++)
                  for (int k = ci; k < ci + 3; k++)
                      for (int l = cj; l < cj + 3; l++)
                          if (k != i || l != j) m.addConstraint(neq(rows[i][j], rows[k][l]));
  }
	
  //...
	
  // Call solver
  Solver s = new CPSolver();
  s.read(m);
  CPSolver.setVerbosity(CPSolver.SOLUTION);
  s.solve();
  CPSolver.flushLogs();
  printGrid(rows, s);
\end{lstlisting}

\noindent\emph{\textbf{Question 2}: which global constraint can be used to model such a problem ? Modify your code to use this constraint.}

The \emph{allDifferent} constraint can be used to remplace every disequality constraint on the first Sudoku model. It improves the efficient of the model and make it more ``readable''.

\begin{lstlisting}
  // Build model
  Model m = new CPModel();
  // Declare variables
  IntegerVariable[][] cols = new IntegerVariable[n][n];
  IntegerVariable[][] rows = makeIntVarArray("rows", n, n, 1, n,Options.V_ENUM);
  
  // Channeling between rows and columns
  for (int i = 0; i < n; i++) {
      for (int j = 0; j < n; j++)
          cols[i][j] = rows[j][i];
  }
	
  // Add alldifferent constraint
  for (int i = 0; i < n; i++) {
      m.addConstraint(allDifferent(cols[i]));
      m.addConstraint(allDifferent(rows[i]));
  }

  // Define sub regions
  IntegerVariable[][] carres = new IntegerVariable[n][n];
  for (int i = 0; i < 3; i++) {
      for (int j = 0; j < 3; j++)
          for (int k = 0; k < 3; k++)
              carres[j + k * 3][i] = rows[0 + k * 3][i + j * 3];
              carres[j + k * 3][i + 3] = rows[1 + k * 3][i + j * 3];
              carres[j + k * 3][i + 6] = rows[2 + k * 3][i + j * 3];
  }
	
  // Add alldifferent on sub regions
  for (int i = 0; i < n; i++) {
      Constraint c = allDifferent(carres[i]);
      m.addConstraint(c);
  }
  
  //...
	
  // Call solver
  Solver s = new CPSolver();
  s.read(m);
  CPSolver.setVerbosity(CPSolver.SOLUTION);
  s.solve();
  printGrid(rows, s);
\end{lstlisting} 

\noindent\emph{\textbf{Question 3}: Test for both model the initial propagation step (use choco} \texttt{propagate()} \emph{method). What can be noticed ? What is the point in using global constraints ?}

The sudoku problem can be solved just with the propagation. \todo{FIXME explanation.}
The global constraint provides a more efficient filter algorithm, due to more complex deduction.

\subsection{Solution of Exercise 1.4 (The knapsack problem)}\label{solutions:solutionofexercise1.4}\hypertarget{solutions:solutionofexercise1.4}{}

(\hyperlink{exercises:exercise1.4}{Problem})

\noindent\emph{\textbf{Question 1} : In the first place, we will not consider the idea of maximizing the energetic value. Try to find a satisfying solution by modelling and implementing the problem within choco.}

\begin{lstlisting}
	Model m = new CPModel();
	
	obj1 = makeIntVar("obj1", 0, 5,Options.V_ENUM);
	obj2 = makeIntVar("obj2", 0, 7,Options.V_ENUM);
	obj3 = makeIntVar("obj3", 0, 10,Options.V_ENUM);
	c = makeIntVar("cost", 1, 1000000,Options.V_BOUND);
	
	int capacity = 34;
	int[] volumes = new int[]{7, 5, 3};
	int[] energy = new int[]{6, 4, 2};
	
	m.addConstraint(leq(scalar(volumes, new IntegerVariable[]{obj1, obj2, obj3}), capacity));
	m.addConstraint(eq(scalar(energy, new IntegerVariable[]{obj1, obj2, obj3}), c));
	
	Solver s = new CPSolver();
	s.read(m);

	s.solve();
	
	System.out.println("("+s.getVar(obj1).getVal()+","+s.getVar(obj2).getVal()+","
                       +s.getVar(obj3).getVal()+") cost = "+ s.getVar(c).getVal());
\end{lstlisting}

\noindent\emph{\textbf{Question 2} : Find and use the choco method to maximise the energetic value of the knapsack.}
Replace \mylst{s.solve()} by:
\begin{lstlisting}
	s.maximize(s.getVar(c), false);
\end{lstlisting}

\noindent\emph{\textbf{Question 3} : Propose a Value selector heuristic to improve the efficiency of the model.}

It can be improved using the following value selector strategy. It iterates over decreasing values of every domain variables: 
\begin{lstlisting}
  s.setValIntIterator(new DecreasingDomain());
\end{lstlisting}

\subsection{Solution of Exercise 1.5 (The n-queens problem)}\label{solutions:solutionofexercise1.5}\hypertarget{solutions:solutionofexercise1.5}{}
(\hyperlink{exercises:exercise1.5}{Problem})

\noindent\emph{\textbf{Question 1} : propose and implement a model based on one} $L_{i}$ \emph{variable for every row...}
\begin{lstlisting}
  Model m = new CPModel();
  
  IntegerVariable[] queens = new IntegerVariable[n];
  for (int i = 0; i < n; i++) {
      queens[i] = makeIntVar("Q" + i, 1, n,Options.V_ENUM);
  }
	
  for (int i = 0; i < n; i++) {
      for (int j = i + 1; j < n; j++) {
          int k = j - i;
          m.addConstraint(neq(queens[i], queens[j]));
          m.addConstraint(neq(queens[i], plus(queens[j], k)));  // diagonal
          m.addConstraint(neq(queens[i], minus(queens[j], k))); // diagonal
      }
  }
	
  Solver s = new CPSolver();
  s.read(m);
  CPSolver.setVerbosity(CPSolver.SOLUTION);
  int timeLimit = 60000;
  s.setTimeLimit(timeLimit);
  s.solve();
  CPSolver.flushLogs();
\end{lstlisting}

\noindent\emph{\textbf{Question 2} : Add a redundant model by considering variable on the columns ($C_i$). Continue to use simple difference constraints.}

\begin{lstlisting}
  Model m = new CPModel();
	
  IntegerVariable[] queens = new IntegerVariable[n];
  IntegerVariable[] queensdual = new IntegerVariable[n];
  for (int i = 0; i < n; i++) {
      queens[i] = makeIntVar("Q" + i, 1, n,Options.V_ENUM);
      queensdual[i] = makeIntVar("QD" + i, 1, n,Options.V_ENUM);
  }
	
  for (int i = 0; i < n; i++) {
      for (int j = i + 1; j < n; j++) {
          int k = j - i;
          m.addConstraint(neq(queens[i], queens[j]));
          m.addConstraint(neq(queens[i], plus(queens[j], k)));  // diagonal
          m.addConstraint(neq(queens[i], minus(queens[j], k))); // diagonal
      }
  }

  for (int i = 0; i < n; i++) {
      for (int j = i + 1; j < n; j++) {
          int k = j - i;
          m.addConstraint(neq(queensdual[i], queensdual[j]));
          m.addConstraint(neq(queensdual[i], plus(queensdual[j], k)));  // diagonal
          m.addConstraint(neq(queensdual[i], minus(queensdual[j], k))); // diagonal
      }
  }
  m.addConstraint(inverseChanneling(queens, queensdual));
  
  Solver s = new CPSolver();
  s.read(m);
  
  s.setVarIntSelector(new MinDomain(s,s.getVar(queens)));
  
  CPSolver.setVerbosity(CPSolver.SOLUTION);
  s.setLoggingMaxDepth(50);
  int timeLimit = 60000;
  s.setTimeLimit(timeLimit);
  s.solve();
  CPSolver.flushLogs();
\end{lstlisting}

\noindent\emph{\textbf{Question 3} : Compare the number of nodes created to find the solutions with both models. How can you explain such a difference ?}

The channeling permit to reduce more nodes from the tree search... \todo{FIXME}

\noindent\emph{\textbf{Question 4} : Add to the previous implemented model the following heuristics,
\begin{itemize}
	\item Select first the line variable ($L_i$) which has the smallest domain ;
	\item Select the value $j\in L_i$ so that the associated column variable $C_j$ has the smallest domain.
\end{itemize}
Again, compare both approaches in term of nodes number and solving time to find ONE solution for $n = 75, 90, 95, 105$.}

Add the following lines to your program (after the reading of the model):
\begin{lstlisting}
	s.setVarIntSelector(new MinDomain(s,s.getVar(queens)));
	s.setValIntSelector(new NQueenValueSelector(s.getVar(queensdual)));
\end{lstlisting}
The variable selector strategy (\texttt{MinDomain}) already exists in Choco. It iterates over variables given and returns the variable ordering by creasing domain size. 
The value selector strategy has to be created as follow:
\begin{lstlisting}
  public class NQueenValueSelector implements ValSelector {
	
      // Column variable
      protected IntDomainVar[] dualVar;
	
      // Constructor of the value selector, 
      public NQueenValueSelector(IntDomainVar[] cols) {
          this.dualVar = cols;
      }
	
      // Returns the "best val" that is the smallest column domain size OR -1
      // (-1 is not in the domain of the variables)
      public int getBestVal(IntDomainVar intDomainVar) {
          int minValue = 10000;
          int v0 = -1;
          IntIterator it = intDomainVar.getDomain().getIterator();
          while (it.hasNext()){
              int i = it.next();
              int val = dualVar[i - 1].getDomainSize();
              if (val < minValue)  {
                  minValue = val;
                  v0 = i;
              }
          }
          return v0;
      }
  }
\end{lstlisting}

\noindent\emph{\textbf{Question 5} : what changes are caused by the use of the global constraint \textbf{alldifferent} ?}

\begin{lstlisting}
  Model m = new CPModel();
	
  IntegerVariable[] queens = new IntegerVariable[n];
  IntegerVariable[] queensdual = new IntegerVariable[n];
  IntegerVariable[] diag1 = new IntegerVariable[n];
  IntegerVariable[] diag2 = new IntegerVariable[n];
  IntegerVariable[] diag1dual = new IntegerVariable[n];
  IntegerVariable[] diag2dual = new IntegerVariable[n];
  for (int i = 0; i < n; i++) {
      queens[i] = makeIntVar("Q" + i, 1, n,Options.V_ENUM);
      queensdual[i] = makeIntVar("QD" + i, 1, n,Options.V_ENUM);
      diag1[i] = makeIntVar("D1" + i, 1, 2 * n,Options.V_ENUM);
      diag2[i] = makeIntVar("D2" + i, -n, n,Options.V_ENUM);
      diag1dual[i] = makeIntVar("D1" + i, 1, 2 * n,Options.V_ENUM);
      diag2dual[i] = makeIntVar("D2" + i, -n, n,Options.V_ENUM);
  }
	
  m.addConstraint(allDifferent(queens));
  m.addConstraint(allDifferent(queensdual));
  for (int i = 0; i < n; i++) {
      m.addConstraint(eq(diag1[i], plus(queens[i], i)));
      m.addConstraint(eq(diag2[i], minus(queens[i], i)));
      m.addConstraint(eq(diag1dual[i], plus(queensdual[i], i)));
      m.addConstraint(eq(diag2dual[i], minus(queensdual[i], i)));
  }
  m.addConstraint(inverseChanneling(queens,queensdual));
	
  m.addConstraint(allDifferent(diag1));
  m.addConstraint(allDifferent(diag2));
  m.addConstraint(allDifferent(diag1dual));
  m.addConstraint(allDifferent(diag2dual));
	
  Solver s = new CPSolver();
  s.read(m);
	
  s.setVarIntSelector(new MinDomain(s,s.getVar(queens)));
  s.setValIntSelector(new NQueenValueSelector(s.getVar(queensdual)));
	
  CPSolver.setVerbosity(CPSolver.SOLUTION);
  int timeLimit = 60000;
  s.setTimeLimit(timeLimit);
  s.solve();
  CPSolver.flushLogs();
\end{lstlisting}

\section{I know CP}\label{solutions:iknowcp}\hypertarget{solutions:iknowcp}{}

\subsection{Solution of Exercise 2.1 (Bin packing, cumulative and search strategies)}\label{solutions:solutionofexercise2.1}\hypertarget{solutions:solutionofexercise2.1}{}
(\hyperlink{exercises:exercise2.1}{Problem})

\subsection{Solution of Exercise 2.2 (Social golfer)}\label{solutions:solutionofexercise2.2}\hypertarget{solutions:solutionofexercise2.2}{}
(\hyperlink{exercises:exercise2.2}{Problem})

\subsection{Solution of Exercise 2.3 (Golomb rule)}\label{solutions:solutionofexercise2.3}\hypertarget{solutions:solutionofexercise2.3}{}

\emph{under development}

(\hyperlink{exercises:exercise2.3}{Problem})

\section{I know CP and Choco2.0}\label{solutions:iknowcpandchoco2.0}\hypertarget{solutions:iknowcpandchoco2.0}{}

\subsection{Solution of Exercise 3.1 (Hamiltonian Cycle Problem Traveling Salesman Problem)}\label{solutions:solutionofexercise3.1}\hypertarget{solutions:solutionofexercise3.1}{}

(\hyperlink{exercises:exercise3.1}{Problem})

\subsection{Solution of Exercise 3.2 (Shop scheduling)}\label{solutions:solutionofexercise3.2}\hypertarget{solutions:solutionofexercise3.2}{}

(\hyperlink{exercises:exercise3.2}{Problem})

\emph{under development}
