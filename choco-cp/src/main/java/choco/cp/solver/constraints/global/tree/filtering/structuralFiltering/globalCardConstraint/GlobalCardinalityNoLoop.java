/* * * * * * * * * * * * * * * * * * * * * * * * * 
 *          _       _                            *
 *         |  Â°(..)  |                           *
 *         |_  J||L _|        CHOCO solver       *
 *                                               *
 *    Choco is a java library for constraint     *
 *    satisfaction problems (CSP), constraint    *
 *    programming (CP) and explanation-based     *
 *    constraint solving (e-CP). It is built     *
 *    on a event-based propagation mechanism     *
 *    with backtrackable structures.             *
 *                                               *
 *    Choco is an open-source software,          *
 *    distributed under a BSD licence            *
 *    and hosted by sourceforge.net              *
 *                                               *
 *    + website : http://choco.emn.fr            *
 *    + support : choco@emn.fr                   *
 *                                               *
 *    Copyright (C) F. Laburthe,                 *
 *                  N. Jussien    1999-2008      *
 * * * * * * * * * * * * * * * * * * * * * * * * */
package choco.cp.solver.constraints.global.tree.filtering.structuralFiltering.globalCardConstraint;

import choco.cp.solver.constraints.global.tree.filtering.RemovalsAdvisor;
import choco.cp.solver.constraints.global.tree.structure.internalStructure.graphStructures.graphViews.VarGraphView;
import choco.kernel.solver.ContradictionException;
import choco.kernel.solver.Solver;




public class GlobalCardinalityNoLoop extends AbstractBipartFlow {

    /**
     * boolean for debug and show a trace of the execution
     */
    protected boolean affiche;

    /**
     * data structure related to the graph representation of the input graph
     */
    protected VarGraphView inputGraph;

    /**
     * Constructor: build a global cardinality constraint API, short cut when smallest value equals 0
     *
     * @param solver  the choco problem involving the constraint
     * @param pack  a set of parameters : treeParams, indices, struct, affiche
     */
    public GlobalCardinalityNoLoop(Solver solver, Object[] pack) {
        super(solver, pack);
        this.affiche = (Boolean)pack[2];
        this.minValue = 0;
        this.maxValue = nbLeftVertices; // valeur de l'etat boucle est le nbre de variables peres
        for (int i = 0; i < this.minFlow.length; i++) {
            this.minFlow[i] = struct.getDegree().getLow()[i];
            this.maxFlow[i] = struct.getDegree().getUp()[i];
        }
        this.inputGraph = struct.getInputGraph();
    }

    public void deleteEdgeAndPublish(int i, int j, RemovalsAdvisor rem) {
        deleteMatch(i, j);
        // update the associated bipartite graph
        this.graph[i].set(j + minValue, false);
        // apply removals
        int val = j + minValue;
        if (val >= graph.length) {
            if (inputGraph.getGlobal().getSuccessors(i).get(val)) {
                if (affiche) {
                    LOGGER.info("\t"+solver.getEnvironment().getWorldIndex()+" --> 1-GCC: suppression de l'arc (" + index[i] + "," + val + ")");
                }
                int[] arc = {index[i], val};
                rem.addRemoval(arc);
            }
        } else {
            if (inputGraph.getGlobal().getSuccessors(index[i]).get(val)) {
                if (affiche) {
                    LOGGER.info("\t"+solver.getEnvironment().getWorldIndex()+" --> 2-GCC: suppression de l'arc (" + index[i] + "," + val + ")");
                }
                int[] arc = {index[i], val};
                rem.addRemoval(arc);
            }
        }
    }

    /**
     * Achieves generalized arc consistency in one call
     * <p/>
     * remove arcs connecting two different strongly connected components
     * the event generated by the flow algorithm:
     * discovering that an edge is no longer valid, and posting this event
     * to the constraint solver: since we are already achieving GAC consistency
     * in one single loop.
     * @param rem
     * @return
     * @throws choco.kernel.solver.ContradictionException
     */
    public boolean applyGCC(RemovalsAdvisor rem) throws ContradictionException {
        for (int i = 0; i < nbRightVertices; i++) {
            int nbUsed = 0;
            for (int j = 0; j < nbLeftVertices; j++) {
                if (graph[j].get(i)) nbUsed++;
            }
            if ((nbUsed < minFlow[i]) || !struct.getDegree().isCompatibleDegree()) {
                if (affiche) LOGGER.info("nbUsed = " + nbUsed + " VS minFlow[" + i + "] = " + minFlow[i] + " ==> ECHEC");
                return false;
            }
        }
        propagate(rem);
        return isFeasible;
    }
}
